import { default as EventEmitter } from "eventemitter3";
import { type Address, type Chain, type Hash, type HttpTransport, type RpcTransactionRequest, type Transaction, type Transport } from "viem";
import type { ISmartContractAccount, SignTypedDataParams } from "../account/types.js";
import type { PublicErc4337Client, SupportedTransports } from "../client/types.js";
import { type BatchUserOperationCallData, type UserOperationCallData, type UserOperationOverrides, type UserOperationReceipt, type UserOperationRequest, type UserOperationResponse, type UserOperationStruct } from "../types.js";
import { type IsUndefined, type NoUndefined } from "../utils/index.js";
import type { AccountMiddlewareFn, FeeDataMiddleware, GasEstimatorMiddleware, ISmartAccountProvider, PaymasterAndDataMiddleware, ProviderEvents, SendUserOperationResult, SmartAccountProviderConfig, UpgradeToData } from "./types.js";
export declare const noOpMiddleware: AccountMiddlewareFn;
export declare class SmartAccountProvider<TTransport extends SupportedTransports = Transport> extends EventEmitter<ProviderEvents> implements ISmartAccountProvider<TTransport> {
    private txMaxRetries;
    private txRetryIntervalMs;
    private txRetryMulitplier;
    private feeOptions;
    readonly account?: ISmartContractAccount;
    protected entryPointAddress?: Address;
    protected chain: Chain;
    rpcClient: PublicErc4337Client<TTransport> | PublicErc4337Client<HttpTransport>;
    constructor(config_: SmartAccountProviderConfig<TTransport>);
    request: (args: {
        method: string;
        params?: any[];
    }) => Promise<any>;
    getAddress: () => Promise<`0x${string}`>;
    signMessage: (msg: string | Uint8Array) => Promise<Hash>;
    signTypedData: (params: SignTypedDataParams) => Promise<Hash>;
    signMessageWith6492: (msg: string | Uint8Array) => Promise<`0x${string}`>;
    signTypedDataWith6492: (params: SignTypedDataParams) => Promise<`0x${string}`>;
    sendTransaction: (request: RpcTransactionRequest, overrides?: UserOperationOverrides) => Promise<Hash>;
    buildUserOperationFromTx: (request: RpcTransactionRequest, overrides?: UserOperationOverrides) => Promise<UserOperationStruct>;
    buildUserOperationFromTxs: (requests: RpcTransactionRequest[], overrides?: UserOperationOverrides) => {
        batch: {
            target: `0x${string}`;
            data: `0x${string}`;
            value: bigint;
        }[];
        overrides: Partial<{
            callGasLimit: number | bigint | `0x${string}` | {
                percentage: number;
            } | undefined;
            maxFeePerGas: number | bigint | `0x${string}` | {
                percentage: number;
            } | undefined;
            maxPriorityFeePerGas: number | bigint | `0x${string}` | {
                percentage: number;
            } | undefined;
            preVerificationGas: number | bigint | `0x${string}` | {
                percentage: number;
            } | undefined;
            verificationGasLimit: number | bigint | `0x${string}` | {
                percentage: number;
            } | undefined;
            paymasterAndData: import("../types.js").BytesLike;
        }> | undefined;
    };
    sendTransactions: (requests: RpcTransactionRequest[], overrides?: UserOperationOverrides) => Promise<`0x${string}`>;
    waitForUserOperationTransaction: (hash: Hash) => Promise<Hash>;
    getUserOperationByHash: (hash: Hash) => Promise<UserOperationResponse | null>;
    getUserOperationReceipt: (hash: Hash) => Promise<UserOperationReceipt | null>;
    getTransaction: (hash: Hash) => Promise<Transaction>;
    buildUserOperation: (data: UserOperationCallData | BatchUserOperationCallData, overrides?: UserOperationOverrides) => Promise<UserOperationStruct>;
    sendUserOperation: (data: UserOperationCallData | BatchUserOperationCallData, overrides?: UserOperationOverrides) => Promise<SendUserOperationResult>;
    dropAndReplaceUserOperation: (uoToDrop: UserOperationRequest, overrides?: UserOperationOverrides) => Promise<SendUserOperationResult>;
    checkGasSponsorshipEligibility: (data: UserOperationCallData | BatchUserOperationCallData, overrides?: UserOperationOverrides) => Promise<boolean>;
    private _runMiddlewareStack;
    private _sendUserOperation;
    readonly dummyPaymasterDataMiddleware: AccountMiddlewareFn;
    readonly overridePaymasterDataMiddleware: AccountMiddlewareFn;
    readonly paymasterDataMiddleware: AccountMiddlewareFn;
    readonly gasEstimator: AccountMiddlewareFn;
    readonly feeDataGetter: AccountMiddlewareFn;
    readonly customMiddleware: AccountMiddlewareFn;
    readonly simulateUOMiddleware: AccountMiddlewareFn;
    withPaymasterMiddleware: (overrides: {
        dummyPaymasterDataMiddleware?: PaymasterAndDataMiddleware;
        paymasterDataMiddleware?: PaymasterAndDataMiddleware;
    }) => this;
    withGasEstimator: (override: GasEstimatorMiddleware) => this;
    withFeeDataGetter: (override: FeeDataMiddleware) => this;
    withCustomMiddleware: (override: AccountMiddlewareFn) => this;
    withSimulateUOMiddleware: (override: AccountMiddlewareFn) => this;
    connect: <TAccount extends ISmartContractAccount<Transport, import("../index.js").SmartAccountSigner<any> | undefined>>(fn: (provider: PublicErc4337Client<TTransport> | PublicErc4337Client<HttpTransport>) => TAccount) => IsUndefined<TAccount["providerDecorators"]> extends true ? this & {
        account: TAccount;
    } : this & {
        account: TAccount;
    } & ReturnType<NoUndefined<TAccount["providerDecorators"]>>;
    disconnect: () => this & {
        account: undefined;
    };
    isConnected: <TAccount extends ISmartContractAccount<Transport, import("../index.js").SmartAccountSigner<any> | undefined>>() => this is this & {
        account: TAccount;
    };
    getEntryPointAddress: () => Address;
    extend: <R>(fn: (self: this) => R) => this & R;
    /**
     * Submits a UO (and optionally waits for it to be mined) to upgrade the currently
     * connected account to the specified implementation.
     *
     * @param upgradeTo -- the destination contract implementation
     * @param waitForTxn -- whether or not to wait for the transaction to be mined
     * @returns Either the TX Hash or the User Operation Hash, depending on whether or not `waitForTxn` is true
     */
    upgradeAccount: (upgradeTo: UpgradeToData, waitForTxn?: boolean) => Promise<Hash>;
    private overrideMiddlewareFunction;
}
//# sourceMappingURL=base.d.ts.map