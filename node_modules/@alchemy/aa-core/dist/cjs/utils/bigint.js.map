{"version":3,"file":"bigint.js","sourceRoot":"","sources":["../../../src/utils/bigint.ts"],"names":[],"mappings":";;;AAAA,+BAAwC;AASjC,MAAM,SAAS,GAAG,CAAC,GAAG,IAAc,EAAU,EAAE;IACrD,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;QACjB,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;IAC9D,CAAC;IAED,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC;AANW,QAAA,SAAS,aAMpB;AAQK,MAAM,SAAS,GAAG,CAAC,GAAG,IAAc,EAAU,EAAE;IACrD,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;QACjB,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;IAC9D,CAAC;IAED,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC;AANW,QAAA,SAAS,aAMpB;AAUK,MAAM,WAAW,GAAG,CACzB,KAAmB,EACnB,KAAsC,EACtC,KAAsC,EACtC,EAAE;IACF,KAAK,GAAG,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAC7C,KAAK,GAAG,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAE7C,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,GAAG,KAAK,EAAE,CAAC;QACpD,MAAM,IAAI,KAAK,CACb,8BAA8B,KAAK,6BAA6B,KAAK,EAAE,CACxE,CAAC;IACJ,CAAC;IAED,IAAI,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IACxB,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,GAAG,GAAG,EAAE,CAAC;QACjC,GAAG,GAAG,KAAK,CAAC;IACd,CAAC;IACD,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,GAAG,GAAG,EAAE,CAAC;QACjC,GAAG,GAAG,KAAK,CAAC;IACd,CAAC;IACD,OAAO,GAAG,CAAC;AACb,CAAC,CAAC;AAtBW,QAAA,WAAW,eAsBtB;AAEF,IAAY,YAGX;AAHD,WAAY,YAAY;IACtB,2DAAc,CAAA;IACd,uDAAY,CAAA;AACd,CAAC,EAHW,YAAY,4BAAZ,YAAY,QAGvB;AAgBM,MAAM,aAAa,GAAG,CAC3B,IAAkB,EAClB,OAAe,EACf,eAA6B,YAAY,CAAC,QAAQ,EAClD,EAAE;IACF,IAAI,YAAY,KAAK,YAAY,CAAC,QAAQ,EAAE,CAAC;QAC3C,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,OAAO,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC;IAC/C,CAAC;IAED,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,GAAG,IAAI,CAAC;AACzC,CAAC,CAAC;AAVW,QAAA,aAAa,iBAUxB;AAkBK,MAAM,aAAa,GAAG,CAAC,MAAc,EAAU,EAAE,CACtD,MAAM,CAAC,IAAA,gBAAS,EAAC,IAAA,YAAK,EAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AADtB,QAAA,aAAa,iBACS","sourcesContent":["import { keccak256, toHex } from \"viem\";\nimport type { BigNumberish } from \"../types\";\n\n/**\n * Returns the max bigint in a list of bigints\n *\n * @param args a list of bigints to get the max of\n * @returns the max bigint in the list\n */\nexport const bigIntMax = (...args: bigint[]): bigint => {\n  if (!args.length) {\n    throw new Error(\"bigIntMax requires at least one argument\");\n  }\n\n  return args.reduce((m, c) => (m > c ? m : c));\n};\n\n/**\n * Returns the min bigint in a list of bigints\n *\n * @param args a list of bigints to get the max of\n * @returns the min bigint in the list\n */\nexport const bigIntMin = (...args: bigint[]): bigint => {\n  if (!args.length) {\n    throw new Error(\"bigIntMin requires at least one argument\");\n  }\n\n  return args.reduce((m, c) => (m < c ? m : c));\n};\n\n/**\n * Given a bigint and a min-max range, returns the min-max clamped bigint value\n *\n * @param value a bigint value to clamp\n * @param lower lower bound min max tuple value\n * @param upper upper bound min max tuple value\n * @returns the clamped bigint value per given range\n */\nexport const bigIntClamp = (\n  value: BigNumberish,\n  lower: BigNumberish | null | undefined,\n  upper: BigNumberish | null | undefined\n) => {\n  lower = lower != null ? BigInt(lower) : null;\n  upper = upper != null ? BigInt(upper) : null;\n\n  if (upper != null && lower != null && upper < lower) {\n    throw new Error(\n      `invalid range: upper bound ${upper} is less than lower bound ${lower}`\n    );\n  }\n\n  let ret = BigInt(value);\n  if (lower != null && lower > ret) {\n    ret = lower;\n  }\n  if (upper != null && upper < ret) {\n    ret = upper;\n  }\n  return ret;\n};\n\nexport enum RoundingMode {\n  ROUND_DOWN = 0,\n  ROUND_UP = 1,\n}\n\n/**\n * Useful if you want to increment a bigint by N% or decrement by N%\n *\n * example:\n * ```\n * const tenPercentIncrease = bigIntPercent(100n, 110n);\n * const tenPercentDecrease = bigIntPercent(100n, 90n);\n * ```\n *\n * @param base -- the base bigint that we want to apply a percent to\n * @param percent -- the percent to apply to the base\n * @param roundingMode -- the rounding mode to use when calculating the percent. defaults to ROUND_UP\n * @returns the base multiplied by the percent and divided by 100\n */\nexport const bigIntPercent = (\n  base: BigNumberish,\n  percent: bigint,\n  roundingMode: RoundingMode = RoundingMode.ROUND_UP\n) => {\n  if (roundingMode === RoundingMode.ROUND_UP) {\n    return (BigInt(base) * percent + 99n) / 100n;\n  }\n\n  return (BigInt(base) * percent) / 100n;\n};\n\n/**\n * Useful if you want to use a string, such as a user's email address, as salt to generate a unique SmartAccount per user.\n *\n * example:\n * ```\n * const salt = stringToIndex(\"alice@example.com\");\n *\n * export const account = new SimpleSmartContractAccount({\n *   index: salt,\n *   // other args omitted...\n * });\n * ```\n *\n * @param phrase -- any string value.\n * @returns the bigint value of the hashed string\n */\nexport const stringToIndex = (phrase: string): bigint =>\n  BigInt(keccak256(toHex(phrase)));\n"]}