import type { Address } from "abitype";
import type { Hash, Hex, HttpTransport, Transport } from "viem";
import type { SignTypedDataParameters } from "viem/accounts";
import type { z } from "zod";
import type { PublicErc4337Client, SupportedTransports } from "../client/types";
import type { ISmartAccountProvider } from "../provider/types";
import type { SmartAccountSigner } from "../signer/types";
import type { BatchUserOperationCallData } from "../types";
import type { SimpleSmartAccountParamsSchema, createBaseSmartAccountParamsSchema } from "./schema";
export type SignTypedDataParams = Omit<SignTypedDataParameters, "privateKey">;
export type BaseSmartAccountParams<TTransport extends SupportedTransports = Transport, TOwner extends SmartAccountSigner | undefined = SmartAccountSigner | undefined> = z.input<ReturnType<typeof createBaseSmartAccountParamsSchema<TTransport, TOwner>>>;
export type SimpleSmartAccountParams<TTransport extends SupportedTransports = Transport, TOwner extends SmartAccountSigner = SmartAccountSigner> = z.input<ReturnType<typeof SimpleSmartAccountParamsSchema<TTransport, TOwner>>>;
export interface ISmartContractAccount<TTransport extends SupportedTransports = Transport, TOwner extends SmartAccountSigner | undefined = SmartAccountSigner | undefined> {
    readonly rpcProvider: PublicErc4337Client<TTransport> | PublicErc4337Client<HttpTransport>;
    providerDecorators?: <P extends ISmartAccountProvider<TTransport>>(provider: P) => unknown;
    getInitCode(): Promise<Hex>;
    getDummySignature(): Hex;
    encodeExecute(target: string, value: bigint, data: string): Promise<Hex>;
    encodeBatchExecute(txs: BatchUserOperationCallData): Promise<Hex>;
    getNonce(): Promise<bigint>;
    signUserOperationHash(uoHash: Hash): Promise<Hash>;
    signMessage(msg: string | Uint8Array | Hex): Promise<Hex>;
    signTypedData(params: SignTypedDataParams): Promise<Hash>;
    signMessageWith6492(msg: string | Uint8Array | Hex): Promise<Hex>;
    signTypedDataWith6492(params: SignTypedDataParams): Promise<Hash>;
    getAddress(): Promise<Address>;
    getOwner(): TOwner;
    getFactoryAddress(): Address;
    getEntryPointAddress(): Address;
    extend: <R>(extendFn: (self: this) => R) => this & R;
    encodeUpgradeToAndCall: (upgradeToImplAddress: Address, upgradeToInitData: Hex) => Promise<Hex>;
}
