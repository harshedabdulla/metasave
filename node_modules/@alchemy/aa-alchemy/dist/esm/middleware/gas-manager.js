import { deepHexlify, filterUndefined, isBigNumberish, isPercentage, resolveProperties, } from "@alchemy/aa-core";
import { fromHex } from "viem";
export const withAlchemyGasManager = (provider, config, gasEstimationOptions = { estimateGas: true }) => {
    const fallbackGasEstimator = gasEstimationOptions.fallbackGasEstimator ?? provider.gasEstimator;
    const fallbackFeeDataGetter = gasEstimationOptions.fallbackFeeDataGetter ?? provider.feeDataGetter;
    return gasEstimationOptions.estimateGas
        ? provider
            .withGasEstimator(async (struct, overrides, feeOptions) => {
            if (overrides?.paymasterAndData === "0x") {
                const result = await fallbackGasEstimator(struct, overrides, feeOptions);
                return {
                    callGasLimit: (await result.callGasLimit) ?? 0n,
                    preVerificationGas: (await result.preVerificationGas) ?? 0n,
                    verificationGasLimit: (await result.verificationGasLimit) ?? 0n,
                };
            }
            else {
                return {
                    callGasLimit: 0n,
                    preVerificationGas: 0n,
                    verificationGasLimit: 0n,
                };
            }
        })
            .withFeeDataGetter(async (struct, overrides, feeOptions) => {
            let maxFeePerGas = (await struct.maxFeePerGas) ?? 0n;
            let maxPriorityFeePerGas = (await struct.maxPriorityFeePerGas) ?? 0n;
            if (overrides?.paymasterAndData === "0x") {
                const result = await fallbackFeeDataGetter(struct, overrides, feeOptions);
                maxFeePerGas = (await result.maxFeePerGas) ?? maxFeePerGas;
                maxPriorityFeePerGas =
                    (await result.maxPriorityFeePerGas) ?? maxPriorityFeePerGas;
            }
            return {
                maxFeePerGas,
                maxPriorityFeePerGas,
            };
        })
            .withPaymasterMiddleware(withAlchemyGasAndPaymasterAndDataMiddleware(provider, config))
        : provider.withPaymasterMiddleware(withAlchemyPaymasterAndDataMiddleware(provider, config));
};
const withAlchemyPaymasterAndDataMiddleware = (provider, config) => ({
    dummyPaymasterDataMiddleware: async (_struct) => {
        switch (provider.rpcClient.chain.id) {
            case 1:
            case 10:
            case 137:
            case 42161:
                return {
                    paymasterAndData: "0x4Fd9098af9ddcB41DA48A1d78F91F1398965addcfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c",
                };
            default:
                return {
                    paymasterAndData: "0xc03aac639bb21233e0139381970328db8bceeb67fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c",
                };
        }
    },
    paymasterDataMiddleware: async (struct) => {
        const { paymasterAndData } = await provider.rpcClient.request({
            method: "alchemy_requestPaymasterAndData",
            params: [
                {
                    policyId: config.policyId,
                    entryPoint: provider.getEntryPointAddress(),
                    userOperation: deepHexlify(await resolveProperties(struct)),
                },
            ],
        });
        return { paymasterAndData };
    },
});
const withAlchemyGasAndPaymasterAndDataMiddleware = (provider, config) => ({
    paymasterDataMiddleware: async (struct, overrides, feeOptions) => {
        const userOperation = deepHexlify(await resolveProperties(struct));
        const overrideField = (field) => {
            if (overrides?.[field] != null) {
                if (isBigNumberish(overrides[field])) {
                    return deepHexlify(overrides[field]);
                }
                else {
                    return {
                        percentage: 100 + Number(overrides[field].percentage),
                    };
                }
            }
            if (isPercentage(feeOptions?.[field])) {
                return {
                    percentage: 100 + Number(feeOptions[field].percentage),
                };
            }
            if (fromHex(userOperation[field], "bigint") > 0n) {
                return userOperation[field];
            }
            return undefined;
        };
        const _overrides = filterUndefined({
            maxFeePerGas: overrideField("maxFeePerGas"),
            maxPriorityFeePerGas: overrideField("maxPriorityFeePerGas"),
            callGasLimit: overrideField("callGasLimit"),
            verificationGasLimit: overrideField("verificationGasLimit"),
            preVerificationGas: overrideField("preVerificationGas"),
        });
        const result = await provider.rpcClient.request({
            method: "alchemy_requestGasAndPaymasterAndData",
            params: [
                {
                    policyId: config.policyId,
                    entryPoint: provider.getEntryPointAddress(),
                    userOperation: userOperation,
                    dummySignature: userOperation.signature,
                    overrides: Object.keys(_overrides).length > 0 ? _overrides : undefined,
                },
            ],
        });
        return result;
    },
});
//# sourceMappingURL=gas-manager.js.map