import { SmartAccountProvider, createPublicErc4337Client, deepHexlify, } from "@alchemy/aa-core";
import { Alchemy } from "alchemy-sdk";
import {} from "viem";
import { getDefaultUserOperationFeeOptions } from "../defaults.js";
import { withAlchemyGasFeeEstimator } from "../middleware/gas-fees.js";
import { withAlchemyGasManager, } from "../middleware/gas-manager.js";
import { withAlchemyUserOpSimulation } from "../middleware/simulate-uo.js";
import { AlchemyProviderConfigSchema, AlchemySdkClientSchema, } from "../schema.js";
export class AlchemyProvider extends SmartAccountProvider {
    constructor(config_) {
        const config = AlchemyProviderConfigSchema.parse(config_);
        const { chain, entryPointAddress, opts, ...connectionConfig } = config;
        const rpcUrl = connectionConfig.rpcUrl == null
            ? `${chain.rpcUrls.alchemy.http[0]}/${connectionConfig.apiKey ?? ""}`
            : connectionConfig.rpcUrl;
        const client = createPublicErc4337Client({
            chain: chain,
            rpcUrl,
            ...(connectionConfig.jwt != null && {
                fetchOptions: {
                    headers: {
                        Authorization: `Bearer ${connectionConfig.jwt}`,
                    },
                },
            }),
        });
        const feeOptions = config.opts?.feeOptions ?? getDefaultUserOperationFeeOptions(chain);
        super({
            rpcProvider: client,
            entryPointAddress,
            chain,
            opts: { ...opts, feeOptions },
        });
        Object.defineProperty(this, "rpcUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "simulateUserOperationAssetChanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (data, overrides) => {
                const uoStruct = deepHexlify(await this.buildUserOperation(data, overrides));
                return this.rpcClient.request({
                    method: "alchemy_simulateUserOperationAssetChanges",
                    params: [uoStruct, this.getEntryPointAddress()],
                });
            }
        });
        this.rpcUrl = rpcUrl;
        withAlchemyGasFeeEstimator(this);
    }
    withAlchemyGasManager(config, delegateGasEstimation = true) {
        if (!this.isConnected()) {
            throw new Error("AlchemyProvider: account is not set, did you call `connect` first?");
        }
        return withAlchemyGasManager(this, config, {
            estimateGas: delegateGasEstimation,
        });
    }
    withAlchemyUserOpSimulation() {
        if (!this.isConnected()) {
            throw new Error("AlchemyProvider: account is not set, did you call `connect` first?");
        }
        return withAlchemyUserOpSimulation(this);
    }
    withAlchemyEnhancedApis(alchemy) {
        AlchemySdkClientSchema.parse(alchemy);
        if (alchemy.config.url && alchemy.config.url !== this.rpcUrl) {
            throw new Error("Alchemy SDK client JSON-RPC URL must match AlchemyProvider JSON-RPC URL");
        }
        const alchemyUrl = `https://${alchemy.config.network}.g.alchemy.com/v2/${alchemy.config.apiKey}`;
        if (alchemyUrl !== this.rpcUrl) {
            throw new Error("Alchemy SDK client JSON-RPC URL must match AlchemyProvider JSON-RPC URL");
        }
        return this.extend(() => {
            return {
                core: alchemy.core,
                nft: alchemy.nft,
                transact: alchemy.transact,
                debug: alchemy.debug,
                ws: alchemy.ws,
                notify: alchemy.notify,
                config: alchemy.config,
            };
        });
    }
}
//# sourceMappingURL=base.js.map