import { type SmartAccountSigner, type SupportedTransports } from "@alchemy/aa-core";
import { type Transport } from "viem";
import { z } from "zod";
import { pluginManagerDecorator } from "../plugin-manager/decorator.js";
import type { IMSCA } from "../types.js";
import type { Executor, Factory, SignerMethods } from "./types.js";
export type ModularAccountBuilderParams<TTransport extends SupportedTransports = Transport, TOwner extends SmartAccountSigner = SmartAccountSigner> = z.input<ReturnType<typeof ModularAccountBuilderParamsSchema<TTransport, TOwner>>>;
export declare const ModularAccountBuilderParamsSchema: <TTransport extends SupportedTransports = Transport, TOwner extends SmartAccountSigner<any> = SmartAccountSigner<any>>() => z.ZodObject<{
    initCode: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    chain: z.ZodType<import("viem").Chain<import("viem").ChainFormatters | undefined>, z.ZodTypeDef, import("viem").Chain<import("viem").ChainFormatters | undefined>>;
    rpcClient: z.ZodUnion<[z.ZodString, z.ZodType<import("@alchemy/aa-core").PublicErc4337Client<TTransport>, z.ZodTypeDef, import("@alchemy/aa-core").PublicErc4337Client<TTransport>>]>;
    factoryAddress: z.ZodEffects<z.ZodString, `0x${string}`, string>;
    entryPointAddress: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    accountAddress: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    owner: z.ZodType<TOwner, z.ZodTypeDef, TOwner>;
    index: z.ZodOptional<z.ZodBigInt>;
}, "strip", z.ZodTypeAny, z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
    initCode: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    chain: z.ZodType<import("viem").Chain<import("viem").ChainFormatters | undefined>, z.ZodTypeDef, import("viem").Chain<import("viem").ChainFormatters | undefined>>;
    rpcClient: z.ZodUnion<[z.ZodString, z.ZodType<import("@alchemy/aa-core").PublicErc4337Client<TTransport>, z.ZodTypeDef, import("@alchemy/aa-core").PublicErc4337Client<TTransport>>]>;
    factoryAddress: z.ZodEffects<z.ZodString, `0x${string}`, string>;
    entryPointAddress: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    accountAddress: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    owner: z.ZodType<TOwner, z.ZodTypeDef, TOwner>;
    index: z.ZodOptional<z.ZodBigInt>;
}>, "chain" | "rpcClient" | "factoryAddress" | (undefined extends TOwner ? never : "owner")> extends infer T ? { [k in keyof T]: z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
    initCode: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    chain: z.ZodType<import("viem").Chain<import("viem").ChainFormatters | undefined>, z.ZodTypeDef, import("viem").Chain<import("viem").ChainFormatters | undefined>>;
    rpcClient: z.ZodUnion<[z.ZodString, z.ZodType<import("@alchemy/aa-core").PublicErc4337Client<TTransport>, z.ZodTypeDef, import("@alchemy/aa-core").PublicErc4337Client<TTransport>>]>;
    factoryAddress: z.ZodEffects<z.ZodString, `0x${string}`, string>;
    entryPointAddress: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    accountAddress: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    owner: z.ZodType<TOwner, z.ZodTypeDef, TOwner>;
    index: z.ZodOptional<z.ZodBigInt>;
}>, "chain" | "rpcClient" | "factoryAddress" | (undefined extends TOwner ? never : "owner")>[k]; } : never, z.baseObjectInputType<{
    initCode: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    chain: z.ZodType<import("viem").Chain<import("viem").ChainFormatters | undefined>, z.ZodTypeDef, import("viem").Chain<import("viem").ChainFormatters | undefined>>;
    rpcClient: z.ZodUnion<[z.ZodString, z.ZodType<import("@alchemy/aa-core").PublicErc4337Client<TTransport>, z.ZodTypeDef, import("@alchemy/aa-core").PublicErc4337Client<TTransport>>]>;
    factoryAddress: z.ZodEffects<z.ZodString, `0x${string}`, string>;
    entryPointAddress: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    accountAddress: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    owner: z.ZodType<TOwner, z.ZodTypeDef, TOwner>;
    index: z.ZodOptional<z.ZodBigInt>;
}> extends infer T_1 ? { [k_1 in keyof T_1]: z.baseObjectInputType<{
    initCode: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    chain: z.ZodType<import("viem").Chain<import("viem").ChainFormatters | undefined>, z.ZodTypeDef, import("viem").Chain<import("viem").ChainFormatters | undefined>>;
    rpcClient: z.ZodUnion<[z.ZodString, z.ZodType<import("@alchemy/aa-core").PublicErc4337Client<TTransport>, z.ZodTypeDef, import("@alchemy/aa-core").PublicErc4337Client<TTransport>>]>;
    factoryAddress: z.ZodEffects<z.ZodString, `0x${string}`, string>;
    entryPointAddress: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    accountAddress: z.ZodOptional<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
    owner: z.ZodType<TOwner, z.ZodTypeDef, TOwner>;
    index: z.ZodOptional<z.ZodBigInt>;
}>[k_1]; } : never>;
export declare class MSCABuilder {
    executor?: Executor;
    signer?: SignerMethods;
    factory?: Factory;
    withExecutor(executor: Executor): this & {
        executor: Executor;
    };
    withSigner(methods: SignerMethods): this & {
        signer: SignerMethods;
    };
    withFactory(initCode: Factory): this & {
        factory: Factory;
    };
    build<TTransport extends SupportedTransports = Transport, TOwner extends SmartAccountSigner = SmartAccountSigner>(params: ModularAccountBuilderParams<TTransport, TOwner>): IMSCA<TTransport, TOwner, ReturnType<typeof pluginManagerDecorator>>;
}
//# sourceMappingURL=index.d.ts.map