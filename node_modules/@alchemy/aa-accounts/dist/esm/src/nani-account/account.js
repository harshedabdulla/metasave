import { BaseSmartContractAccount, SmartAccountProvider, } from "@alchemy/aa-core";
import { concatHex, decodeFunctionResult, encodeFunctionData, numberToHex, hexToBytes, } from "viem";
import { NaniAccountAbi } from "./abis/NaniAccountAbi.js";
import { NaniAccountFactoryAbi } from "./abis/NaniAccountFactoryAbi.js";
export class NaniAccount extends BaseSmartContractAccount {
    constructor(params) {
        super(params);
        Object.defineProperty(this, "owner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "salt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.index = params.index ?? 0n;
        this.owner = params.owner;
        this.salt = params.salt;
    }
    async signTypedData(params) {
        return this.owner.signTypedData(params);
    }
    async getOwnerAddress() {
        const callResult = await this.rpcProvider.call({
            to: await this.getAddress(),
            data: encodeFunctionData({
                abi: NaniAccountAbi,
                functionName: "owner",
            }),
        });
        if (callResult.data == null) {
            throw new Error("could not get on-chain owner");
        }
        const decodedCallResult = decodeFunctionResult({
            abi: NaniAccountAbi,
            functionName: "owner",
            data: callResult.data,
        });
        if (decodedCallResult !== (await this.owner.getAddress())) {
            throw new Error("on-chain owner does not match account owner");
        }
        return decodedCallResult;
    }
    async getAddress() {
        const callResult = await this.rpcProvider.call({
            to: this.factoryAddress,
            data: encodeFunctionData({
                abi: NaniAccountFactoryAbi,
                functionName: "getAddress",
                args: [await this.getSalt()],
            }),
        });
        if (callResult.data == null) {
            throw new Error("could not get deterministic address");
        }
        const decodedCallResult = decodeFunctionResult({
            abi: NaniAccountFactoryAbi,
            functionName: "getAddress",
            data: callResult.data,
        });
        return decodedCallResult;
    }
    getDummySignature() {
        return "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
    }
    signMessage(msg) {
        if (typeof msg === "string" && msg.startsWith("0x")) {
            msg = hexToBytes(msg);
        }
        else if (typeof msg === "string") {
            msg = new TextEncoder().encode(msg);
        }
        return this.owner.signMessage(msg);
    }
    async encodeExecute(target, value, data) {
        return encodeFunctionData({
            abi: NaniAccountAbi,
            functionName: "execute",
            args: [target, value, data],
        });
    }
    async encodeBatchExecute(calls) {
        return encodeFunctionData({
            abi: NaniAccountAbi,
            functionName: "executeBatch",
            args: [
                calls.map((call) => ({
                    ...call,
                    value: call.value ?? 0n,
                })),
            ],
        });
    }
    static encodeExecuteDelegate(delegate, data) {
        return encodeFunctionData({
            abi: NaniAccountAbi,
            functionName: "delegateExecute",
            args: [delegate, data],
        });
    }
    static encodeTransferOwnership(newOwner) {
        return encodeFunctionData({
            abi: NaniAccountAbi,
            functionName: "transferOwnership",
            args: [newOwner],
        });
    }
    static async transferOwnership(provider, newOwner, waitForTxn = false) {
        const data = this.encodeTransferOwnership(await newOwner.getAddress());
        const result = await provider.sendUserOperation({
            target: await provider.getAddress(),
            data,
        });
        provider.account.owner = newOwner;
        if (waitForTxn) {
            return provider.waitForUserOperationTransaction(result.hash);
        }
        return result.hash;
    }
    async getAccountInitCode() {
        const result = await concatHex([
            this.factoryAddress,
            await this.getFactoryInitCode(),
        ]);
        return result;
    }
    async getSalt() {
        if (this.salt) {
            if (this.salt.slice(0, 42) !== (await this.owner.getAddress())) {
                throw new Error("Salt does not match owner");
            }
            else {
                return this.salt;
            }
        }
        return concatHex([
            await this.owner.getAddress(),
            numberToHex(this.index, { size: 12 }),
        ]);
    }
    async getFactoryInitCode() {
        try {
            return encodeFunctionData({
                abi: NaniAccountFactoryAbi,
                functionName: "createAccount",
                args: [await this.owner.getAddress(), await this.getSalt()],
            });
        }
        catch (err) {
            throw new Error("Factory Code generation failed");
        }
    }
}
//# sourceMappingURL=account.js.map