import {} from "@alchemy/aa-core";
import { Address as zAddress } from "abitype/zod";
import { concatHex, encodeFunctionData, hexToBigInt, } from "viem";
import { z } from "zod";
import { SessionKeyExecutor, SessionKeyPlugin, SessionKeySigner, StandardExecutor, getDefaultMultiOwnerMSCAFactoryAddress, } from "../index.js";
import { MultiOwnerMSCAFactoryAbi } from "./abis/MultiOwnerMSCAFactory.js";
import { MultiOwnerTokenReceiverMSCAFactoryAbi } from "./abis/MultiOwnerTokenReceiverMSCAFactory.js";
import { accountLoupeDecorators } from "./account-loupe/decorator.js";
import { MSCABuilder, ModularAccountBuilderParamsSchema, } from "./builder/index.js";
import { WrapWith712SignerMethods } from "./builder/wrapped-signer.js";
import { MultiOwnerPlugin } from "./plugins/multi-owner/index.js";
import { TokenReceiverPlugin } from "./plugins/token-receiver/plugin.js";
export const createMultiOwnerMSCASchema = () => ModularAccountBuilderParamsSchema()
    .extend({
    owners: z.array(zAddress).default([]),
    index: z.bigint().optional().default(0n),
    excludeDefaultTokenReceiverPlugin: z.boolean().optional().default(false),
    factoryAddress: zAddress.optional(),
})
    .transform((params) => {
    const factoryAddress = params.factoryAddress ??
        getDefaultMultiOwnerMSCAFactoryAddress(params.chain, params.excludeDefaultTokenReceiverPlugin);
    return {
        ...params,
        factoryAddress,
    };
});
export const createMultiOwnerMSCABuilder = (params_) => {
    const params = createMultiOwnerMSCASchema().parse(params_);
    const builder = new MSCABuilder()
        .withFactory(async (acct) => {
        const ownerAddress = await params.owner.getAddress();
        const owners = Array.from(new Set([...params.owners, ownerAddress]))
            .filter((x) => hexToBigInt(x) !== 0n)
            .sort((a, b) => {
            const bigintA = hexToBigInt(a);
            const bigintB = hexToBigInt(b);
            return bigintA < bigintB ? -1 : bigintA > bigintB ? 1 : 0;
        });
        return concatHex([
            acct.getFactoryAddress(),
            encodeFunctionData({
                abi: params.excludeDefaultTokenReceiverPlugin
                    ? MultiOwnerMSCAFactoryAbi
                    : MultiOwnerTokenReceiverMSCAFactoryAbi,
                functionName: "createAccount",
                args: [params.index, owners],
            }),
        ]);
    })
        .withExecutor(StandardExecutor)
        .withSigner(WrapWith712SignerMethods);
    return builder;
};
export const createMultiOwnerMSCA = (params_) => {
    const params = createMultiOwnerMSCASchema().parse(params_);
    const builder = createMultiOwnerMSCABuilder(params);
    let account = builder
        .build(params)
        .extendWithPluginMethods(MultiOwnerPlugin)
        .extend(accountLoupeDecorators);
    if (params.excludeDefaultTokenReceiverPlugin) {
        return account;
    }
    return account.extendWithPluginMethods(TokenReceiverPlugin);
};
export const createMultiOwnerMSCAWithSessionKey = async (params_, sessionKeyOverrides) => {
    const params = createMultiOwnerMSCASchema().parse(params_);
    const builder = createMultiOwnerMSCABuilder(params);
    const sessionKeySigner = new SessionKeySigner({
        fallbackSigner: params.owner,
        ...sessionKeyOverrides,
    });
    sessionKeySigner.setKeyActive(sessionKeyOverrides?.keyActive ?? true);
    const baseAccount = builder.build(params);
    const accountAddress = await baseAccount.getAddress();
    const initCode = await baseAccount.getInitCode();
    let account = builder
        .withExecutor(SessionKeyExecutor)
        .build({ ...params, owner: sessionKeySigner, initCode, accountAddress })
        .extendWithPluginMethods(MultiOwnerPlugin)
        .extendWithPluginMethods(SessionKeyPlugin)
        .extend(accountLoupeDecorators);
    if (params.excludeDefaultTokenReceiverPlugin) {
        return account;
    }
    return account.extendWithPluginMethods(TokenReceiverPlugin);
};
//# sourceMappingURL=multi-owner-account.js.map