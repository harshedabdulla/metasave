{"version":3,"file":"multi-owner-account.js","sourceRoot":"","sources":["../../../../src/msca/multi-owner-account.ts"],"names":[],"mappings":"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","sourcesContent":["import { type SupportedTransports } from \"@alchemy/aa-core\";\nimport { Address as zAddress } from \"abitype/zod\";\nimport {\n  concatHex,\n  encodeFunctionData,\n  hexToBigInt,\n  type FallbackTransport,\n  type Transport,\n} from \"viem\";\nimport { z } from \"zod\";\nimport {\n  SessionKeyExecutor,\n  SessionKeyPlugin,\n  SessionKeySigner,\n  StandardExecutor,\n  getDefaultMultiOwnerMSCAFactoryAddress,\n} from \"../index.js\";\nimport { MultiOwnerMSCAFactoryAbi } from \"./abis/MultiOwnerMSCAFactory.js\";\nimport { MultiOwnerTokenReceiverMSCAFactoryAbi } from \"./abis/MultiOwnerTokenReceiverMSCAFactory.js\";\nimport { accountLoupeDecorators } from \"./account-loupe/decorator.js\";\nimport {\n  MSCABuilder,\n  ModularAccountBuilderParamsSchema,\n} from \"./builder/index.js\";\nimport { WrapWith712SignerMethods } from \"./builder/wrapped-signer.js\";\nimport { MultiOwnerPlugin } from \"./plugins/multi-owner/index.js\";\nimport type { SessionKeySignerConfig } from \"./plugins/session-key/signer.js\";\nimport { TokenReceiverPlugin } from \"./plugins/token-receiver/plugin.js\";\n\nexport const createMultiOwnerMSCASchema = <\n  TTransport extends SupportedTransports = Transport\n>() =>\n  ModularAccountBuilderParamsSchema<TTransport>()\n    .extend({\n      owners: z.array(zAddress).default([]),\n      index: z.bigint().optional().default(0n),\n      excludeDefaultTokenReceiverPlugin: z.boolean().optional().default(false),\n      factoryAddress: zAddress.optional(),\n    })\n    .transform((params) => {\n      const factoryAddress =\n        params.factoryAddress ??\n        getDefaultMultiOwnerMSCAFactoryAddress(\n          params.chain,\n          params.excludeDefaultTokenReceiverPlugin\n        );\n\n      return {\n        ...params,\n        factoryAddress,\n      };\n    });\n\nexport type MultiOwnerMSCAParams = z.input<\n  ReturnType<typeof createMultiOwnerMSCASchema>\n>;\n\nexport const createMultiOwnerMSCABuilder = <\n  TTransport extends Transport | FallbackTransport = Transport\n>(\n  params_: MultiOwnerMSCAParams\n) => {\n  const params = createMultiOwnerMSCASchema<TTransport>().parse(params_);\n\n  const builder = new MSCABuilder()\n    .withFactory(async (acct) => {\n      const ownerAddress = await params.owner.getAddress();\n      // owners need to be dedupe + ordered in ascending order and not == to zero address\n      const owners = Array.from(new Set([...params.owners, ownerAddress]))\n        .filter((x) => hexToBigInt(x) !== 0n)\n        .sort((a, b) => {\n          const bigintA = hexToBigInt(a);\n          const bigintB = hexToBigInt(b);\n\n          return bigintA < bigintB ? -1 : bigintA > bigintB ? 1 : 0;\n        });\n      return concatHex([\n        acct.getFactoryAddress(),\n        encodeFunctionData({\n          abi: params.excludeDefaultTokenReceiverPlugin\n            ? MultiOwnerMSCAFactoryAbi\n            : MultiOwnerTokenReceiverMSCAFactoryAbi,\n          functionName: \"createAccount\",\n          args: [params.index, owners],\n        }),\n      ]);\n    })\n    .withExecutor(StandardExecutor)\n    .withSigner(WrapWith712SignerMethods);\n\n  return builder;\n};\n\nexport const createMultiOwnerMSCA = <\n  TTransport extends Transport | FallbackTransport = Transport\n>(\n  params_: MultiOwnerMSCAParams\n) => {\n  const params = createMultiOwnerMSCASchema<TTransport>().parse(params_);\n  const builder = createMultiOwnerMSCABuilder<TTransport>(params);\n\n  let account = builder\n    .build(params)\n    .extendWithPluginMethods(MultiOwnerPlugin)\n    .extend(accountLoupeDecorators);\n\n  if (params.excludeDefaultTokenReceiverPlugin) {\n    return account;\n  }\n\n  return account.extendWithPluginMethods(TokenReceiverPlugin);\n};\n\n/**\n * This method will create a new MSCA account leveraging a session key signer with fallback to your provided signer\n * You can use this with a deployed or undeployed account. If the account is not deployed yet, it will deploy it for you\n * on your first UO and sign the UO with your fallback signer. After that, you can install the session key plugin and add\n * the session key to that account.\n *\n * @param params_ -- configuration params for creating a new MSCA account\n * @param sessionKeyOverrides -- overrides for the session key signer config\n * @returns a new MSCA account leveraging a session key signer with fallback to your provided signer\n */\nexport const createMultiOwnerMSCAWithSessionKey = async <\n  TTransport extends Transport | FallbackTransport = Transport\n>(\n  params_: MultiOwnerMSCAParams,\n  sessionKeyOverrides?: Pick<\n    SessionKeySignerConfig<MultiOwnerMSCAParams[\"owner\"]>,\n    \"storageKey\" | \"storageType\"\n  > & { keyActive?: boolean }\n) => {\n  const params = createMultiOwnerMSCASchema<TTransport>().parse(params_);\n  const builder = createMultiOwnerMSCABuilder<TTransport>(params);\n  const sessionKeySigner = new SessionKeySigner({\n    fallbackSigner: params.owner,\n    ...sessionKeyOverrides,\n  });\n  sessionKeySigner.setKeyActive(sessionKeyOverrides?.keyActive ?? true);\n\n  // get the base account so we can get the init code and address of the account\n  // NOTE: if the user passed in an initCode or accountAddress, we will use those instead\n  // because the builder's params handles that logic\n  const baseAccount = builder.build(params);\n  const accountAddress = await baseAccount.getAddress();\n  const initCode = await baseAccount.getInitCode();\n\n  let account = builder\n    .withExecutor(SessionKeyExecutor)\n    .build({ ...params, owner: sessionKeySigner, initCode, accountAddress })\n    .extendWithPluginMethods(MultiOwnerPlugin)\n    .extendWithPluginMethods(SessionKeyPlugin)\n    .extend(accountLoupeDecorators);\n\n  if (params.excludeDefaultTokenReceiverPlugin) {\n    return account;\n  }\n\n  return account.extendWithPluginMethods(TokenReceiverPlugin);\n};\n"]}