{"version":3,"file":"executor.js","sourceRoot":"","sources":["../../../../../../src/msca/plugins/session-key/executor.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Address, BatchUserOperationCallData } from \"@alchemy/aa-core\";\nimport { encodeFunctionData, type Hex } from \"viem\";\nimport { IStandardExecutorAbi } from \"../../abis/IStandardExecutor.js\";\nimport type { Executor } from \"../../builder/types\";\nimport { SessionKeyPlugin, SessionKeyPluginAbi } from \"./plugin.js\";\nimport { SESSION_KEY_SIGNER_TYPE_PFX, SessionKeySigner } from \"./signer.js\";\n\n/**\n * Use this with the `SessionKeySigner` {@link SessionKeySigner} in order to\n * receive the fallback functionality.\n *\n * @param acct the account this executor is attached to\n * @returns\n */\nexport const SessionKeyExecutor: Executor = (acct) => {\n  const owner = acct.getOwner();\n  if (!owner) {\n    throw new Error(\"Account must be connected to an owner\");\n  }\n\n  const isSessionKeyActive = async (pluginAddress?: Address) => {\n    // TODO: check if the account actually has the plugin installed\n    // either via account loupe or checking if the supports interface call passes on the account\n    const contract = SessionKeyPlugin.getContract(\n      acct.rpcProvider,\n      pluginAddress\n    );\n\n    const [accountAddress, sessionKey] = await Promise.all([\n      acct.getAddress(),\n      owner.getAddress(),\n    ]);\n\n    // if this throws, then session key or the plugin is not installed\n    if (\n      await contract.read\n        .isSessionKeyOf([accountAddress, sessionKey])\n        .catch(() => false)\n    ) {\n      // TODO: Technically the key could be over its usage limit, but we'll come back to that later because\n      // that requires the provider trying to validate a UO first\n      return true;\n    }\n\n    return (\n      // TODO: this is not a good way of doing this check, but we can come back to this later\n      !owner.signerType.startsWith(SESSION_KEY_SIGNER_TYPE_PFX) ||\n      (owner.signerType.startsWith(SESSION_KEY_SIGNER_TYPE_PFX) &&\n        (owner as SessionKeySigner<any>).isKeyActive())\n    );\n  };\n\n  return {\n    async encodeExecute(\n      target: Address,\n      value: bigint,\n      data: Hex\n    ): Promise<`0x${string}`> {\n      if (!isSessionKeyActive()) {\n        return encodeFunctionData({\n          abi: IStandardExecutorAbi,\n          functionName: \"execute\",\n          args: [target, value, data],\n        });\n      }\n\n      return encodeFunctionData({\n        abi: SessionKeyPluginAbi,\n        functionName: \"executeWithSessionKey\",\n        args: [[{ target, value, data }], await owner.getAddress()],\n      });\n    },\n\n    async encodeBatchExecute(\n      txs: BatchUserOperationCallData\n    ): Promise<`0x${string}`> {\n      if (!isSessionKeyActive()) {\n        return encodeFunctionData({\n          abi: IStandardExecutorAbi,\n          functionName: \"executeBatch\",\n          args: [\n            txs.map((tx) => ({\n              target: tx.target,\n              data: tx.data,\n              value: tx.value ?? 0n,\n            })),\n          ],\n        });\n      }\n\n      return encodeFunctionData({\n        abi: SessionKeyPluginAbi,\n        functionName: \"executeWithSessionKey\",\n        args: [\n          txs.map((tx) => ({\n            target: tx.target,\n            data: tx.data,\n            value: tx.value ?? 0n,\n          })),\n          await owner.getAddress(),\n        ],\n      });\n    },\n  };\n};\n"]}