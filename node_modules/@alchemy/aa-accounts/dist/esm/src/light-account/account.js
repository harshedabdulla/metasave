import { SimpleSmartContractAccount, } from "@alchemy/aa-core";
import { concatHex, decodeFunctionResult, encodeFunctionData, fromHex, hashMessage, hashTypedData, isBytes, trim, } from "viem";
import { LightAccountAbi } from "./abis/LightAccountAbi.js";
import { LightAccountFactoryAbi } from "./abis/LightAccountFactoryAbi.js";
import { LightAccountUnsupported1271Factories, LightAccountVersions, } from "./utils.js";
export class LightSmartContractAccount extends SimpleSmartContractAccount {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "getLightAccountVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                const implAddress = await this.getImplementationAddress();
                const implToVersion = new Map(Object.entries(LightAccountVersions).map(([key, value]) => [
                    value.implAddress,
                    key,
                ]));
                const factoryToVersion = new Map(Object.entries(LightAccountVersions).map(([key, value]) => [
                    value.factoryAddress,
                    key,
                ]));
                const version = fromHex(implAddress, "bigint") === 0n
                    ? factoryToVersion.get(this.factoryAddress.toLowerCase())
                    : implToVersion.get(implAddress.toLowerCase());
                if (!version) {
                    throw new Error("Could not determine LightAccount version");
                }
                return version;
            }
        });
        Object.defineProperty(this, "signWith1271Wrapper", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (msg) => {
                return this.owner.signTypedData({
                    domain: {
                        chainId: Number(this.rpcProvider.chain.id),
                        name: "LightAccount",
                        verifyingContract: await this.getAddress(),
                        version: "1",
                    },
                    types: {
                        LightAccountMessage: [{ name: "message", type: "bytes" }],
                    },
                    message: {
                        message: msg,
                    },
                    primaryType: "LightAccountMessage",
                });
            }
        });
        Object.defineProperty(this, "encodeUpgradeToAndCall", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (upgradeToImplAddress, upgradeToInitData) => {
                const provider = this.rpcProvider;
                const accountAddress = await this.getAddress();
                const storage = await provider.getStorageAt({
                    address: accountAddress,
                    slot: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
                });
                if (storage == null) {
                    throw new Error("could not get storage");
                }
                const implementationAddresses = Object.values(LightAccountVersions).map((x) => x.implAddress);
                if (fromHex(storage, "number") !== 0 &&
                    !implementationAddresses.some((x) => x === trim(storage))) {
                    throw new Error("could not determine if smart account implementation is light account");
                }
                return encodeFunctionData({
                    abi: LightAccountAbi,
                    functionName: "upgradeToAndCall",
                    args: [upgradeToImplAddress, upgradeToInitData],
                });
            }
        });
    }
    async signMessage(msg) {
        const version = await this.getLightAccountVersion();
        switch (version) {
            case "v1.0.1":
                return this.owner.signMessage(msg);
            case "v1.0.2":
                throw new Error(`Version ${version} of LightAccount doesn't support 1271`);
            default:
                return this.signWith1271Wrapper(hashMessage(typeof msg === "string" && !isBytes(msg)
                    ? msg
                    : {
                        raw: msg,
                    }));
        }
    }
    async signTypedData(params) {
        const version = await this.getLightAccountVersion();
        switch (version) {
            case "v1.0.1":
                return this.owner.signTypedData(params);
            case "v1.0.2":
                throw new Error(`Version ${version} of LightAccount doesn't support 1271`);
            default:
                return this.signWith1271Wrapper(hashTypedData(params));
        }
    }
    async signUserOperationHash(uoHash) {
        return this.owner.signMessage(uoHash);
    }
    async getOwnerAddress() {
        const callResult = await this.rpcProvider.call({
            to: await this.getAddress(),
            data: encodeFunctionData({
                abi: LightAccountAbi,
                functionName: "owner",
            }),
        });
        if (callResult.data == null) {
            throw new Error("could not get on-chain owner");
        }
        const decodedCallResult = decodeFunctionResult({
            abi: LightAccountAbi,
            functionName: "owner",
            data: callResult.data,
        });
        if (decodedCallResult !== (await this.owner.getAddress())) {
            throw new Error("on-chain owner does not match account owner");
        }
        return decodedCallResult;
    }
    static encodeTransferOwnership(newOwner) {
        return encodeFunctionData({
            abi: LightAccountAbi,
            functionName: "transferOwnership",
            args: [newOwner],
        });
    }
    static async transferOwnership(provider, newOwner, waitForTxn = false) {
        const data = this.encodeTransferOwnership(await newOwner.getAddress());
        const result = await provider.sendUserOperation({
            target: await provider.getAddress(),
            data,
        });
        const accountAddress = await provider.getAddress();
        const initCode = await provider.account.getInitCode();
        provider.connect((rpcClient) => new LightSmartContractAccount({
            rpcClient,
            chain: rpcClient.chain,
            owner: newOwner,
            entryPointAddress: provider.account.getEntryPointAddress(),
            factoryAddress: provider.account.getFactoryAddress(),
            index: provider.account.index,
            initCode,
            accountAddress,
        }));
        if (waitForTxn) {
            return provider.waitForUserOperationTransaction(result.hash);
        }
        return result.hash;
    }
    async getAccountInitCode() {
        const index = LightAccountUnsupported1271Factories.has(this.factoryAddress.toLowerCase())
            ? 0n
            : this.index;
        return concatHex([
            this.factoryAddress,
            encodeFunctionData({
                abi: LightAccountFactoryAbi,
                functionName: "createAccount",
                args: [await this.owner.getAddress(), index],
            }),
        ]);
    }
}
//# sourceMappingURL=account.js.map