{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../plugingen/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  asyncPipe,\n  type ConnectionConfig,\n  type RequiredBy,\n} from \"@alchemy/aa-core\";\nimport { type Plugin } from \"@wagmi/cli\";\nimport dedent from \"dedent\";\nimport { createPublicClient, getContract, http, type Chain } from \"viem\";\nimport type { PluginGenConfig } from \"../plugindefs/types.js\";\nimport { IPluginAbi } from \"../src/msca/abis/IPlugin.js\";\nimport { ContractAbiGenPhase } from \"./phases/contract-abi-gen.js\";\nimport { ContractAddressesGenPhase } from \"./phases/contract-addresses-gen.js\";\nimport { ExecutionAbiGenPhase } from \"./phases/execution-abi-gen.js\";\nimport { PluginGeneratorPhase } from \"./phases/plugin-generator/index.js\";\nimport type { Phase, PhaseInput } from \"./types.js\";\n\n// Add more phases here if needed\nconst phases: Phase[] = [\n  ContractAddressesGenPhase,\n  PluginGeneratorPhase,\n  ExecutionAbiGenPhase,\n  ContractAbiGenPhase,\n];\n\nexport function plugingen({\n  chain,\n  connectionConfig,\n  config,\n}: {\n  chain: Chain;\n  connectionConfig: ConnectionConfig;\n  config: PluginGenConfig;\n}): RequiredBy<Plugin, \"run\"> {\n  return {\n    name: \"ERC6900PluginGen: This file is auto-generated by plugingen\",\n    run: async ({ contracts }) => {\n      // Setup plugin generator\n      const imports: Map<\n        string,\n        {\n          types: Set<string>;\n          members: Set<string>;\n        }\n      > = new Map();\n      const addImport: PhaseInput[\"addImport\"] = (moduleName, member) => {\n        if (!imports.has(moduleName)) {\n          imports.set(moduleName, {\n            types: new Set(),\n            members: new Set(),\n          });\n        }\n\n        const module = imports.get(moduleName)!;\n        if (member.isType) {\n          module.types.add(member.name);\n        } else {\n          module.members.add(member.name);\n        }\n      };\n      const content: string[] = [];\n      const types: Map<string, { definition: string; isPublic: boolean }> =\n        new Map();\n      const addType: PhaseInput[\"addType\"] = (typeName, typeDef, isPublic) => {\n        if (types.has(typeName)) {\n          throw new Error(`Type ${typeName} already exists`);\n        }\n\n        types.set(typeName, {\n          definition: typeDef.replace(\";\", \"\"),\n          isPublic: isPublic ?? false,\n        });\n      };\n\n      if (contracts.length !== 1) {\n        throw new Error(\n          \"plugingen should be used with only one Contract per plugin invocation\"\n        );\n      }\n\n      const rpcUrl =\n        connectionConfig.rpcUrl == null\n          ? `${chain.rpcUrls.alchemy.http[0]}/${\n              connectionConfig.apiKey ?? process.env.API_KEY\n            }`\n          : connectionConfig.rpcUrl;\n\n      const client = createPublicClient({\n        chain,\n        transport: http(rpcUrl, {\n          fetchOptions: {\n            headers: {\n              Authorization: `Bearer ${connectionConfig.jwt}`,\n            },\n          },\n        }),\n      });\n\n      const contract = contracts[0];\n      // This is done to clear out the ABI generated by wagmi\n      contract.content = \"\";\n      if (contract.address == null) {\n        throw new Error(\"contract must have at least one address\");\n      }\n\n      const address =\n        typeof contract.address === \"string\"\n          ? { [chain.id]: contract.address }\n          : contract.address;\n\n      if (!(chain.id in address)) {\n        throw new Error(\n          `contract address missing for the reference chain ${chain.id}`\n        );\n      }\n\n      const plugin = getContract({\n        address: address[chain.id],\n        abi: IPluginAbi,\n        publicClient: client,\n      });\n\n      const result = await asyncPipe(...phases)({\n        addImport,\n        addType,\n        content,\n        config,\n        contract,\n        plugin,\n      });\n\n      // Aggregate Result of phase\n      const finalContent = dedent`\n        ${Array.from(types.entries())\n          .map(\n            ([name, type]) =>\n              `${type.isPublic ? \"export\" : \"\"} type ${name} = ${\n                type.definition\n              };`\n          )\n          .join(\"\\n\")}\n\n        ${result.content.join(\"\\n\\n\")}\n      `;\n\n      const finalImports = Array.from(imports.entries())\n        .map(([moduleName, { members, types }]) => {\n          return dedent`\n            import { ${Array.from(members.values()).join(\",\")} ${\n            members.size > 0 ? \",\" : \"\"\n          } ${Array.from(types.values())\n            .map((x) => `type ${x}`)\n            .join(\",\")} } from \"${moduleName}\";\n        `;\n        })\n        .join(\"\\n\");\n\n      return {\n        imports: finalImports,\n        content: finalContent,\n      };\n    },\n  };\n}\n"]}