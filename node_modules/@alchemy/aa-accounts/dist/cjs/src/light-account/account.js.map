{"version":3,"file":"account.js","sourceRoot":"","sources":["../../../../src/light-account/account.ts"],"names":[],"mappings":";;;AAAA,8CAK0B;AAC1B,+BAcc;AACd,kEAA4D;AAC5D,gFAA0E;AAC1E,yCAIoB;AAEpB,MAAa,yBAEX,SAAQ,oCAAsC;IAFhD;;QA+CS;;;;mBAAyB,KAAK,IAAkC,EAAE;gBACvE,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,wBAAwB,EAAE,CAAC;gBAC1D,MAAM,aAAa,GAAG,IAAI,GAAG,CAC3B,MAAM,CAAC,OAAO,CAAC,+BAAoB,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC;oBACzD,KAAK,CAAC,WAAW;oBACjB,GAA0B;iBAC3B,CAAC,CACH,CAAC;gBACF,MAAM,gBAAgB,GAAG,IAAI,GAAG,CAC9B,MAAM,CAAC,OAAO,CAAC,+BAAoB,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC;oBACzD,KAAK,CAAC,cAAc;oBACpB,GAA0B;iBAC3B,CAAC,CACH,CAAC;gBAEF,MAAM,OAAO,GACX,IAAA,cAAO,EAAC,WAAW,EAAE,QAAQ,CAAC,KAAK,EAAE;oBACnC,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,cAAc,CAAC,WAAW,EAAa,CAAC;oBACpE,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,WAAW,CAAC,WAAW,EAAa,CAAC,CAAC;gBAE9D,IAAI,CAAC,OAAO,EAAE,CAAC;oBACb,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;gBAC9D,CAAC;gBAED,OAAO,OAAO,CAAC;YACjB,CAAC;WAAC;QAEM;;;;mBAAsB,KAAK,EAAE,GAAS,EAA0B,EAAE;gBACxE,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC;oBAG9B,MAAM,EAAE;wBACN,OAAO,EAAE,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC;wBAC1C,IAAI,EAAE,cAAc;wBACpB,iBAAiB,EAAE,MAAM,IAAI,CAAC,UAAU,EAAE;wBAC1C,OAAO,EAAE,GAAG;qBACb;oBACD,KAAK,EAAE;wBACL,mBAAmB,EAAE,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;qBAC1D;oBACD,OAAO,EAAE;wBACP,OAAO,EAAE,GAAG;qBACb;oBACD,WAAW,EAAE,qBAAqB;iBACnC,CAAC,CAAC;YACL,CAAC;WAAC;QAiCF;;;;mBAAyB,KAAK,EAC5B,oBAA6B,EAC7B,iBAAsB,EACR,EAAE;gBAChB,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC;gBAClC,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;gBAE/C,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,YAAY,CAAC;oBAC1C,OAAO,EAAE,cAAc;oBAEvB,IAAI,EAAE,oEAAoE;iBAC3E,CAAC,CAAC;gBAEH,IAAI,OAAO,IAAI,IAAI,EAAE,CAAC;oBACpB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;gBAC3C,CAAC;gBAED,MAAM,uBAAuB,GAAG,MAAM,CAAC,MAAM,CAAC,+BAAoB,CAAC,CAAC,GAAG,CACrE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,CACrB,CAAC;gBAGF,IACE,IAAA,cAAO,EAAC,OAAO,EAAE,QAAQ,CAAC,KAAK,CAAC;oBAChC,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,IAAA,WAAI,EAAC,OAAO,CAAC,CAAC,EACzD,CAAC;oBACD,MAAM,IAAI,KAAK,CACb,sEAAsE,CACvE,CAAC;gBACJ,CAAC;gBAED,OAAO,IAAA,yBAAkB,EAAC;oBACxB,GAAG,EAAE,oCAAe;oBACpB,YAAY,EAAE,kBAAkB;oBAChC,IAAI,EAAE,CAAC,oBAAoB,EAAE,iBAAiB,CAAC;iBAChD,CAAC,CAAC;YACL,CAAC;WAAC;IAgFJ,CAAC;IA9OU,KAAK,CAAC,WAAW,CAAC,GAAwB;QACjD,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACpD,QAAQ,OAAO,EAAE,CAAC;YAChB,KAAK,QAAQ;gBACX,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;YACrC,KAAK,QAAQ;gBACX,MAAM,IAAI,KAAK,CACb,WAAW,OAAO,uCAAuC,CAC1D,CAAC;YACJ;gBACE,OAAO,IAAI,CAAC,mBAAmB,CAC7B,IAAA,kBAAW,EACT,OAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,IAAA,cAAO,EAAC,GAAG,CAAC;oBACtC,CAAC,CAAC,GAAG;oBACL,CAAC,CAAC;wBACE,GAAG,EAAE,GAAG;qBACT,CACN,CACF,CAAC;QACN,CAAC;IACH,CAAC;IAEQ,KAAK,CAAC,aAAa,CAC1B,MAA2B;QAE3B,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACpD,QAAQ,OAAO,EAAE,CAAC;YAChB,KAAK,QAAQ;gBACX,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;YAC1C,KAAK,QAAQ;gBACX,MAAM,IAAI,KAAK,CACb,WAAW,OAAO,uCAAuC,CAC1D,CAAC;YACJ;gBACE,OAAO,IAAI,CAAC,mBAAmB,CAAC,IAAA,oBAAa,EAAC,MAAM,CAAC,CAAC,CAAC;QAC3D,CAAC;IACH,CAAC;IAEQ,KAAK,CAAC,qBAAqB,CAClC,MAAqB;QAErB,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;IACxC,CAAC;IAsDD,KAAK,CAAC,eAAe;QACnB,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;YAC7C,EAAE,EAAE,MAAM,IAAI,CAAC,UAAU,EAAE;YAC3B,IAAI,EAAE,IAAA,yBAAkB,EAAC;gBACvB,GAAG,EAAE,oCAAe;gBACpB,YAAY,EAAE,OAAO;aACtB,CAAC;SACH,CAAC,CAAC;QAEH,IAAI,UAAU,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC;YAC5B,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;QAClD,CAAC;QAED,MAAM,iBAAiB,GAAG,IAAA,2BAAoB,EAAC;YAC7C,GAAG,EAAE,oCAAe;YACpB,YAAY,EAAE,OAAO;YACrB,IAAI,EAAE,UAAU,CAAC,IAAI;SACtB,CAAC,CAAC;QAEH,IAAI,iBAAiB,KAAK,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC;YAC1D,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;QACjE,CAAC;QAED,OAAO,iBAAiB,CAAC;IAC3B,CAAC;IA8CD,MAAM,CAAC,uBAAuB,CAAC,QAAiB;QAC9C,OAAO,IAAA,yBAAkB,EAAC;YACxB,GAAG,EAAE,oCAAe;YACpB,YAAY,EAAE,mBAAmB;YACjC,IAAI,EAAE,CAAC,QAAQ,CAAC;SACjB,CAAC,CAAC;IACL,CAAC;IAWD,MAAM,CAAC,KAAK,CAAC,iBAAiB,CAI5B,QAEC,EACD,QAA4B,EAC5B,aAAsB,KAAK;QAE3B,MAAM,IAAI,GAAG,IAAI,CAAC,uBAAuB,CAAC,MAAM,QAAQ,CAAC,UAAU,EAAE,CAAC,CAAC;QACvE,MAAM,MAAM,GAAG,MAAM,QAAQ,CAAC,iBAAiB,CAAC;YAC9C,MAAM,EAAE,MAAM,QAAQ,CAAC,UAAU,EAAE;YACnC,IAAI;SACL,CAAC,CAAC;QAEH,MAAM,cAAc,GAAG,MAAM,QAAQ,CAAC,UAAU,EAAE,CAAC;QACnD,MAAM,QAAQ,GAAG,MAAM,QAAQ,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;QACtD,QAAQ,CAAC,OAAO,CACd,CAAC,SAAS,EAAE,EAAE,CACZ,IAAI,yBAAyB,CAAC;YAC5B,SAAS;YACT,KAAK,EAAE,SAAS,CAAC,KAAK;YACtB,KAAK,EAAE,QAAQ;YACf,iBAAiB,EAAE,QAAQ,CAAC,OAAO,CAAC,oBAAoB,EAAE;YAC1D,cAAc,EAAE,QAAQ,CAAC,OAAO,CAAC,iBAAiB,EAAE;YACpD,KAAK,EAAE,QAAQ,CAAC,OAAO,CAAC,KAAK;YAC7B,QAAQ;YACR,cAAc;SACf,CAAC,CACL,CAAC;QAEF,IAAI,UAAU,EAAE,CAAC;YACf,OAAO,QAAQ,CAAC,+BAA+B,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC/D,CAAC;QAED,OAAO,MAAM,CAAC,IAAI,CAAC;IACrB,CAAC;IAEkB,KAAK,CAAC,kBAAkB;QACzC,MAAM,KAAK,GAAG,+CAAoC,CAAC,GAAG,CACpD,IAAI,CAAC,cAAc,CAAC,WAAW,EAAa,CAC7C;YACC,CAAC,CAAC,EAAE;YACJ,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;QAEf,OAAO,IAAA,gBAAS,EAAC;YACf,IAAI,CAAC,cAAc;YACnB,IAAA,yBAAkB,EAAC;gBACjB,GAAG,EAAE,kDAAsB;gBAC3B,YAAY,EAAE,eAAe;gBAC7B,IAAI,EAAE,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,EAAE,KAAK,CAAC;aAC7C,CAAC;SACH,CAAC,CAAC;IACL,CAAC;CACF;AAjPD,8DAiPC","sourcesContent":["import {\n  SimpleSmartContractAccount,\n  type ISmartAccountProvider,\n  type SignTypedDataParams,\n  type SmartAccountSigner,\n} from \"@alchemy/aa-core\";\nimport {\n  concatHex,\n  decodeFunctionResult,\n  encodeFunctionData,\n  fromHex,\n  hashMessage,\n  hashTypedData,\n  isBytes,\n  trim,\n  type Address,\n  type FallbackTransport,\n  type Hash,\n  type Hex,\n  type Transport,\n} from \"viem\";\nimport { LightAccountAbi } from \"./abis/LightAccountAbi.js\";\nimport { LightAccountFactoryAbi } from \"./abis/LightAccountFactoryAbi.js\";\nimport {\n  LightAccountUnsupported1271Factories,\n  LightAccountVersions,\n  type LightAccountVersion,\n} from \"./utils.js\";\n\nexport class LightSmartContractAccount<\n  TTransport extends Transport | FallbackTransport = Transport\n> extends SimpleSmartContractAccount<TTransport> {\n  override async signMessage(msg: string | Uint8Array): Promise<`0x${string}`> {\n    const version = await this.getLightAccountVersion();\n    switch (version) {\n      case \"v1.0.1\":\n        return this.owner.signMessage(msg);\n      case \"v1.0.2\":\n        throw new Error(\n          `Version ${version} of LightAccount doesn't support 1271`\n        );\n      default:\n        return this.signWith1271Wrapper(\n          hashMessage(\n            typeof msg === \"string\" && !isBytes(msg)\n              ? msg\n              : {\n                  raw: msg,\n                }\n          )\n        );\n    }\n  }\n\n  override async signTypedData(\n    params: SignTypedDataParams\n  ): Promise<`0x${string}`> {\n    const version = await this.getLightAccountVersion();\n    switch (version) {\n      case \"v1.0.1\":\n        return this.owner.signTypedData(params);\n      case \"v1.0.2\":\n        throw new Error(\n          `Version ${version} of LightAccount doesn't support 1271`\n        );\n      default:\n        return this.signWith1271Wrapper(hashTypedData(params));\n    }\n  }\n\n  override async signUserOperationHash(\n    uoHash: `0x${string}`\n  ): Promise<`0x${string}`> {\n    return this.owner.signMessage(uoHash);\n  }\n\n  public getLightAccountVersion = async (): Promise<LightAccountVersion> => {\n    const implAddress = await this.getImplementationAddress();\n    const implToVersion = new Map(\n      Object.entries(LightAccountVersions).map(([key, value]) => [\n        value.implAddress,\n        key as LightAccountVersion,\n      ])\n    );\n    const factoryToVersion = new Map(\n      Object.entries(LightAccountVersions).map(([key, value]) => [\n        value.factoryAddress,\n        key as LightAccountVersion,\n      ])\n    );\n\n    const version =\n      fromHex(implAddress, \"bigint\") === 0n\n        ? factoryToVersion.get(this.factoryAddress.toLowerCase() as Address)\n        : implToVersion.get(implAddress.toLowerCase() as Address);\n\n    if (!version) {\n      throw new Error(\"Could not determine LightAccount version\");\n    }\n\n    return version;\n  };\n\n  private signWith1271Wrapper = async (msg: Hash): Promise<`0x${string}`> => {\n    return this.owner.signTypedData({\n      // EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\n      // https://github.com/alchemyplatform/light-account/blob/main/src/LightAccount.sol#L236\n      domain: {\n        chainId: Number(this.rpcProvider.chain.id),\n        name: \"LightAccount\",\n        verifyingContract: await this.getAddress(),\n        version: \"1\",\n      },\n      types: {\n        LightAccountMessage: [{ name: \"message\", type: \"bytes\" }],\n      },\n      message: {\n        message: msg,\n      },\n      primaryType: \"LightAccountMessage\",\n    });\n  };\n\n  /**\n   * Returns the on-chain EOA owner address of the account.\n   *\n   * @returns {Address} the on-chain EOA owner of the account\n   */\n  async getOwnerAddress(): Promise<Address> {\n    const callResult = await this.rpcProvider.call({\n      to: await this.getAddress(),\n      data: encodeFunctionData({\n        abi: LightAccountAbi,\n        functionName: \"owner\",\n      }),\n    });\n\n    if (callResult.data == null) {\n      throw new Error(\"could not get on-chain owner\");\n    }\n\n    const decodedCallResult = decodeFunctionResult({\n      abi: LightAccountAbi,\n      functionName: \"owner\",\n      data: callResult.data,\n    });\n\n    if (decodedCallResult !== (await this.owner.getAddress())) {\n      throw new Error(\"on-chain owner does not match account owner\");\n    }\n\n    return decodedCallResult;\n  }\n\n  encodeUpgradeToAndCall = async (\n    upgradeToImplAddress: Address,\n    upgradeToInitData: Hex\n  ): Promise<Hex> => {\n    const provider = this.rpcProvider;\n    const accountAddress = await this.getAddress();\n\n    const storage = await provider.getStorageAt({\n      address: accountAddress,\n      // the slot at which impl addresses are stored by UUPS\n      slot: \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n    });\n\n    if (storage == null) {\n      throw new Error(\"could not get storage\");\n    }\n\n    const implementationAddresses = Object.values(LightAccountVersions).map(\n      (x) => x.implAddress\n    );\n\n    // only upgrade undeployed accounts (storage 0) or deployed light accounts, error otherwise\n    if (\n      fromHex(storage, \"number\") !== 0 &&\n      !implementationAddresses.some((x) => x === trim(storage))\n    ) {\n      throw new Error(\n        \"could not determine if smart account implementation is light account\"\n      );\n    }\n\n    return encodeFunctionData({\n      abi: LightAccountAbi,\n      functionName: \"upgradeToAndCall\",\n      args: [upgradeToImplAddress, upgradeToInitData],\n    });\n  };\n\n  /**\n   * Encodes the transferOwnership function call using Light Account ABI.\n   *\n   * @param newOwner - the new owner of the account\n   * @returns {Hex} the encoded function call\n   */\n  static encodeTransferOwnership(newOwner: Address): Hex {\n    return encodeFunctionData({\n      abi: LightAccountAbi,\n      functionName: \"transferOwnership\",\n      args: [newOwner],\n    });\n  }\n\n  /**\n   * Transfers ownership of the account to the newOwner on-chain and also updates the owner of the account.\n   * Optionally waits for the transaction to be mined.\n   *\n   * @param provider - the provider to use to send the transaction\n   * @param newOwner - the new owner of the account\n   * @param waitForTxn - whether or not to wait for the transaction to be mined\n   * @returns {Hash} the userOperation hash, or transaction hash if `waitForTxn` is true\n   */\n  static async transferOwnership<\n    P extends ISmartAccountProvider,\n    TTransport extends Transport | FallbackTransport = Transport\n  >(\n    provider: P & {\n      account: LightSmartContractAccount<TTransport>;\n    },\n    newOwner: SmartAccountSigner,\n    waitForTxn: boolean = false\n  ): Promise<Hash> {\n    const data = this.encodeTransferOwnership(await newOwner.getAddress());\n    const result = await provider.sendUserOperation({\n      target: await provider.getAddress(),\n      data,\n    });\n\n    const accountAddress = await provider.getAddress();\n    const initCode = await provider.account.getInitCode();\n    provider.connect(\n      (rpcClient) =>\n        new LightSmartContractAccount({\n          rpcClient,\n          chain: rpcClient.chain,\n          owner: newOwner,\n          entryPointAddress: provider.account.getEntryPointAddress(),\n          factoryAddress: provider.account.getFactoryAddress(),\n          index: provider.account.index,\n          initCode,\n          accountAddress,\n        })\n    );\n\n    if (waitForTxn) {\n      return provider.waitForUserOperationTransaction(result.hash);\n    }\n\n    return result.hash;\n  }\n\n  protected override async getAccountInitCode(): Promise<`0x${string}`> {\n    const index = LightAccountUnsupported1271Factories.has(\n      this.factoryAddress.toLowerCase() as Address\n    )\n      ? 0n\n      : this.index;\n\n    return concatHex([\n      this.factoryAddress,\n      encodeFunctionData({\n        abi: LightAccountFactoryAbi,\n        functionName: \"createAccount\",\n        args: [await this.owner.getAddress(), index],\n      }),\n    ]);\n  }\n}\n"]}