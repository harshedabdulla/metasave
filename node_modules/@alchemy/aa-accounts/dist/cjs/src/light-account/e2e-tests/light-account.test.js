"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const accounts_1 = require("viem/accounts");
const chains_1 = require("viem/chains");
const index_js_1 = require("../../index.js");
const utils_js_1 = require("../../msca/utils.js");
const constants_js_1 = require("./constants.js");
const chain = chains_1.sepolia;
aa_core_1.Logger.setLogLevel(aa_core_1.LogLevel.DEBUG);
describe("Light Account Tests", () => {
    const owner = aa_core_1.LocalAccountSigner.mnemonicToAccountSigner(constants_js_1.LIGHT_ACCOUNT_OWNER_MNEMONIC);
    const undeployedOwner = aa_core_1.LocalAccountSigner.mnemonicToAccountSigner(constants_js_1.UNDEPLOYED_OWNER_MNEMONIC);
    it.each([
        { version: "v1.0.1", expected: true },
        { version: "v1.0.2", throws: true },
        { version: "v1.1.0", expected: true },
    ])("LA version $version should correctly verify 1271 signatures", async ({ version, expected, throws }) => {
        const provider = givenConnectedProvider({ owner, chain, version });
        const message = "test";
        if (!throws) {
            const signature = await provider.signMessage(message);
            expect(await provider.rpcClient.verifyMessage({
                address: await provider.getAddress(),
                message,
                signature,
            })).toBe(expected);
        }
        else {
            await expect(provider.signMessage(message)).rejects.toThrowError();
        }
    });
    it("should successfully get counterfactual address", async () => {
        const provider = givenConnectedProvider({ owner, chain });
        expect(await provider.getAddress()).toMatchInlineSnapshot('"0x86f3B0211764971Ad0Fc8C8898d31f5d792faD84"');
    });
    it("should sign typed data with 6492 successfully for undeployed account", async () => {
        const undeployedProvider = givenConnectedProvider({
            owner: undeployedOwner,
            chain,
        });
        const typedData = {
            types: {
                Request: [{ name: "hello", type: "string" }],
            },
            primaryType: "Request",
            message: {
                hello: "world",
            },
        };
        expect(await undeployedProvider.signTypedDataWith6492(typedData)).toMatchInlineSnapshot('"0x00000000000000000000000000004ec70002a32400f8ae005a26081065620d20000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000445fbfb9cf000000000000000000000000ef9d7530d16df66481adf291dc9a12b44c7f7df00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041ac03c38ea7f6308cf37067659115b9c982cd29354db4e90044cce8a113fd66890588245cf7076f5364de6010e5e5aff42efec5c719b5de3f555d389766518a2b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492"');
    });
    it("should sign message with 6492 successfully for undeployed account", async () => {
        const undeployedProvider = givenConnectedProvider({
            owner: undeployedOwner,
            chain,
        });
        expect(await undeployedProvider.signMessageWith6492("test")).toMatchInlineSnapshot('"0x00000000000000000000000000004ec70002a32400f8ae005a26081065620d20000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000445fbfb9cf000000000000000000000000ef9d7530d16df66481adf291dc9a12b44c7f7df0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004181c6c4855d1cb16616c78e4b99bdde42eeda6bc8fbec920434e196445b64dede539eb9d934092f8e472766ded3f06d1a5f8ed2c209a5aaac7b13f9a8795757381b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492"');
    });
    it("should execute successfully", async () => {
        const provider = givenConnectedProvider({ owner, chain });
        const result = await provider.sendUserOperation({
            target: await provider.getAddress(),
            data: "0x",
        });
        const txnHash = provider.waitForUserOperationTransaction(result.hash);
        await expect(txnHash).resolves.not.toThrowError();
    }, 100000);
    it("should fail to execute if account address is not deployed and not correct", async () => {
        const accountAddress = "0xc33AbD9621834CA7c6Fc9f9CC3c47b9c17B03f9F";
        const newProvider = givenConnectedProvider({
            owner,
            chain,
            accountAddress,
        });
        const result = newProvider.sendUserOperation({
            target: await newProvider.getAddress(),
            data: "0x",
        });
        await expect(result).rejects.toThrowError();
    });
    it("should get counterfactual for undeployed account", async () => {
        const owner = aa_core_1.LocalAccountSigner.privateKeyToAccountSigner((0, accounts_1.generatePrivateKey)());
        const provider = givenConnectedProvider({ owner, chain });
        const address = provider.getAddress();
        await expect(address).resolves.not.toThrowError();
        expect((0, viem_1.isAddress)(await address)).toBe(true);
    });
    it("should get owner successfully", async () => {
        const provider = givenConnectedProvider({ owner, chain });
        expect(await provider.account.getOwnerAddress()).toMatchInlineSnapshot('"0x65eaA2AfDF6c97295bA44C458abb00FebFB3a5FA"');
        expect(await provider.account.getOwnerAddress()).toBe(await owner.getAddress());
    });
    it("should transfer ownership successfully", async () => {
        const provider = givenConnectedProvider({
            owner,
            chain,
        });
        const throwawayOwner = aa_core_1.LocalAccountSigner.privateKeyToAccountSigner((0, accounts_1.generatePrivateKey)());
        const throwawayProvider = givenConnectedProvider({
            owner: throwawayOwner,
            chain,
        });
        const oldOwner = await throwawayOwner.getAddress();
        await provider.sendTransaction({
            from: await provider.getAddress(),
            to: await throwawayProvider.getAddress(),
            data: "0x",
            value: (0, viem_1.toHex)(1000000000000000n),
        });
        const newThrowawayOwner = aa_core_1.LocalAccountSigner.privateKeyToAccountSigner((0, accounts_1.generatePrivateKey)());
        await index_js_1.LightSmartContractAccount.transferOwnership(throwawayProvider, newThrowawayOwner, true);
        const newOwnerViaProvider = await throwawayProvider.account.getOwnerAddress();
        const newOwner = await newThrowawayOwner.getAddress();
        expect(newOwnerViaProvider).not.toBe(oldOwner);
        expect(newOwnerViaProvider).toBe(newOwner);
    }, 100000);
    it("should upgrade a deployed light account to msca successfully", async () => {
        const provider = givenConnectedProvider({
            owner,
            chain,
        });
        const throwawayOwner = aa_core_1.LocalAccountSigner.privateKeyToAccountSigner((0, accounts_1.generatePrivateKey)());
        const throwawayProvider = givenConnectedProvider({
            owner: throwawayOwner,
            chain,
        });
        const accountAddress = await throwawayProvider.getAddress();
        const ownerAddress = await throwawayOwner.getAddress();
        await provider.sendTransaction({
            from: await provider.getAddress(),
            to: accountAddress,
            data: "0x",
            value: (0, viem_1.toHex)(200000000000000000n),
        });
        const { connectFn, ...upgradeToData } = await (0, utils_js_1.getMSCAUpgradeToData)(throwawayProvider);
        await throwawayProvider.upgradeAccount(upgradeToData, true);
        const upgradedProvider = throwawayProvider.connect(connectFn);
        const upgradedAccountAddress = await upgradedProvider.getAddress();
        const owners = await upgradedProvider.account.readOwners();
        expect(upgradedAccountAddress).toBe(accountAddress);
        expect(owners).toContain(ownerAddress);
    }, 200000);
});
const givenConnectedProvider = ({ owner, chain, accountAddress, feeOptions, version = "v1.1.0", }) => {
    const provider = (0, index_js_1.createLightAccountProvider)({
        rpcProvider: `${chain.rpcUrls.alchemy.http[0]}/${constants_js_1.API_KEY}`,
        chain,
        owner,
        accountAddress,
        opts: {
            feeOptions,
            txMaxRetries: 100,
        },
        version,
    });
    return provider;
};
//# sourceMappingURL=light-account.test.js.map