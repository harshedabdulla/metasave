"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LightSmartContractAccount = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const LightAccountAbi_js_1 = require("./abis/LightAccountAbi.js");
const LightAccountFactoryAbi_js_1 = require("./abis/LightAccountFactoryAbi.js");
const utils_js_1 = require("./utils.js");
class LightSmartContractAccount extends aa_core_1.SimpleSmartContractAccount {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "getLightAccountVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                const implAddress = await this.getImplementationAddress();
                const implToVersion = new Map(Object.entries(utils_js_1.LightAccountVersions).map(([key, value]) => [
                    value.implAddress,
                    key,
                ]));
                const factoryToVersion = new Map(Object.entries(utils_js_1.LightAccountVersions).map(([key, value]) => [
                    value.factoryAddress,
                    key,
                ]));
                const version = (0, viem_1.fromHex)(implAddress, "bigint") === 0n
                    ? factoryToVersion.get(this.factoryAddress.toLowerCase())
                    : implToVersion.get(implAddress.toLowerCase());
                if (!version) {
                    throw new Error("Could not determine LightAccount version");
                }
                return version;
            }
        });
        Object.defineProperty(this, "signWith1271Wrapper", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (msg) => {
                return this.owner.signTypedData({
                    domain: {
                        chainId: Number(this.rpcProvider.chain.id),
                        name: "LightAccount",
                        verifyingContract: await this.getAddress(),
                        version: "1",
                    },
                    types: {
                        LightAccountMessage: [{ name: "message", type: "bytes" }],
                    },
                    message: {
                        message: msg,
                    },
                    primaryType: "LightAccountMessage",
                });
            }
        });
        Object.defineProperty(this, "encodeUpgradeToAndCall", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (upgradeToImplAddress, upgradeToInitData) => {
                const provider = this.rpcProvider;
                const accountAddress = await this.getAddress();
                const storage = await provider.getStorageAt({
                    address: accountAddress,
                    slot: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
                });
                if (storage == null) {
                    throw new Error("could not get storage");
                }
                const implementationAddresses = Object.values(utils_js_1.LightAccountVersions).map((x) => x.implAddress);
                if ((0, viem_1.fromHex)(storage, "number") !== 0 &&
                    !implementationAddresses.some((x) => x === (0, viem_1.trim)(storage))) {
                    throw new Error("could not determine if smart account implementation is light account");
                }
                return (0, viem_1.encodeFunctionData)({
                    abi: LightAccountAbi_js_1.LightAccountAbi,
                    functionName: "upgradeToAndCall",
                    args: [upgradeToImplAddress, upgradeToInitData],
                });
            }
        });
    }
    async signMessage(msg) {
        const version = await this.getLightAccountVersion();
        switch (version) {
            case "v1.0.1":
                return this.owner.signMessage(msg);
            case "v1.0.2":
                throw new Error(`Version ${version} of LightAccount doesn't support 1271`);
            default:
                return this.signWith1271Wrapper((0, viem_1.hashMessage)(typeof msg === "string" && !(0, viem_1.isBytes)(msg)
                    ? msg
                    : {
                        raw: msg,
                    }));
        }
    }
    async signTypedData(params) {
        const version = await this.getLightAccountVersion();
        switch (version) {
            case "v1.0.1":
                return this.owner.signTypedData(params);
            case "v1.0.2":
                throw new Error(`Version ${version} of LightAccount doesn't support 1271`);
            default:
                return this.signWith1271Wrapper((0, viem_1.hashTypedData)(params));
        }
    }
    async signUserOperationHash(uoHash) {
        return this.owner.signMessage(uoHash);
    }
    async getOwnerAddress() {
        const callResult = await this.rpcProvider.call({
            to: await this.getAddress(),
            data: (0, viem_1.encodeFunctionData)({
                abi: LightAccountAbi_js_1.LightAccountAbi,
                functionName: "owner",
            }),
        });
        if (callResult.data == null) {
            throw new Error("could not get on-chain owner");
        }
        const decodedCallResult = (0, viem_1.decodeFunctionResult)({
            abi: LightAccountAbi_js_1.LightAccountAbi,
            functionName: "owner",
            data: callResult.data,
        });
        if (decodedCallResult !== (await this.owner.getAddress())) {
            throw new Error("on-chain owner does not match account owner");
        }
        return decodedCallResult;
    }
    static encodeTransferOwnership(newOwner) {
        return (0, viem_1.encodeFunctionData)({
            abi: LightAccountAbi_js_1.LightAccountAbi,
            functionName: "transferOwnership",
            args: [newOwner],
        });
    }
    static async transferOwnership(provider, newOwner, waitForTxn = false) {
        const data = this.encodeTransferOwnership(await newOwner.getAddress());
        const result = await provider.sendUserOperation({
            target: await provider.getAddress(),
            data,
        });
        const accountAddress = await provider.getAddress();
        const initCode = await provider.account.getInitCode();
        provider.connect((rpcClient) => new LightSmartContractAccount({
            rpcClient,
            chain: rpcClient.chain,
            owner: newOwner,
            entryPointAddress: provider.account.getEntryPointAddress(),
            factoryAddress: provider.account.getFactoryAddress(),
            index: provider.account.index,
            initCode,
            accountAddress,
        }));
        if (waitForTxn) {
            return provider.waitForUserOperationTransaction(result.hash);
        }
        return result.hash;
    }
    async getAccountInitCode() {
        const index = utils_js_1.LightAccountUnsupported1271Factories.has(this.factoryAddress.toLowerCase())
            ? 0n
            : this.index;
        return (0, viem_1.concatHex)([
            this.factoryAddress,
            (0, viem_1.encodeFunctionData)({
                abi: LightAccountFactoryAbi_js_1.LightAccountFactoryAbi,
                functionName: "createAccount",
                args: [await this.owner.getAddress(), index],
            }),
        ]);
    }
}
exports.LightSmartContractAccount = LightSmartContractAccount;
//# sourceMappingURL=account.js.map