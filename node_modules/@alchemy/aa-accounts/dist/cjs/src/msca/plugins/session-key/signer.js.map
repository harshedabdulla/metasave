{"version":3,"file":"signer.js","sourceRoot":"","sources":["../../../../../../src/msca/plugins/session-key/signer.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  LocalAccountSigner,\n  SignerSchema,\n  type SignTypedDataParams,\n  type SmartAccountSigner,\n} from \"@alchemy/aa-core\";\nimport type { Hex, PrivateKeyAccount } from \"viem\";\nimport { generatePrivateKey } from \"viem/accounts\";\nimport { z } from \"zod\";\n\nexport const createSessionKeySignerSchema = <\n  TFallback extends SmartAccountSigner\n>() => {\n  return z.object({\n    storageType: z\n      .union([z.literal(\"local-storage\"), z.literal(\"session-storage\")])\n      .default(\"local-storage\"),\n    storageKey: z.string().default(\"session-key-signer:session-key\"),\n    fallbackSigner: z.custom<TFallback>((signer) => SignerSchema.parse(signer)),\n  });\n};\n\nexport type SessionKeySignerConfig<TFallback extends SmartAccountSigner> =\n  z.input<ReturnType<typeof createSessionKeySignerSchema<TFallback>>>;\n\n/**\n * A simple session key signer that uses localStorage or sessionStorage to store\n * a private key. If the key is not found, it will generate a new one and store\n * it in the storage.\n */\n\nexport const SESSION_KEY_SIGNER_TYPE_PFX = \"alchemy:session-key\";\nexport class SessionKeySigner<TFallback extends SmartAccountSigner>\n  implements SmartAccountSigner<LocalAccountSigner<PrivateKeyAccount>>\n{\n  signerType: string;\n  inner: LocalAccountSigner<PrivateKeyAccount>;\n  private keyActive: boolean;\n  private fallback: TFallback;\n  private storageType: \"local-storage\" | \"session-storage\";\n  private storageKey: string;\n\n  constructor(config_: SessionKeySignerConfig<TFallback>) {\n    const config = createSessionKeySignerSchema<TFallback>().parse(config_);\n    this.signerType = `${SESSION_KEY_SIGNER_TYPE_PFX}:${\n      config.fallbackSigner!.signerType\n    }`;\n    this.storageKey = config.storageKey;\n    this.storageType = config.storageType;\n\n    const sessionKey = (() => {\n      const storage =\n        config.storageType === \"session-storage\"\n          ? sessionStorage\n          : localStorage;\n      const key = storage.getItem(this.storageKey);\n\n      if (key) {\n        return key;\n      } else {\n        const newKey = generatePrivateKey();\n        storage.setItem(this.storageKey, newKey);\n        return newKey;\n      }\n    })() as Hex;\n\n    this.inner = LocalAccountSigner.privateKeyToAccountSigner(sessionKey);\n    this.keyActive = true;\n    this.fallback = config.fallbackSigner as TFallback;\n  }\n\n  getAddress: () => Promise<`0x${string}`> = async () => {\n    if (!this.keyActive) {\n      return this.fallback.getAddress();\n    }\n\n    return this.inner.getAddress();\n  };\n\n  signMessage: (msg: string | Uint8Array) => Promise<`0x${string}`> = async (\n    msg\n  ) => {\n    if (!this.keyActive) {\n      return this.fallback.signMessage(msg);\n    }\n\n    return this.inner.signMessage(msg);\n  };\n\n  signTypedData: (params: SignTypedDataParams) => Promise<`0x${string}`> =\n    async (params) => {\n      if (!this.keyActive) {\n        return this.fallback.signTypedData(params);\n      }\n\n      return this.inner.signTypedData(params);\n    };\n\n  /**\n   * Allows you to check if the session key is active or not.\n   * If it is not active, the signer is currently using the fallback signer\n   *\n   * @returns whether or not the session key is active\n   */\n  isKeyActive = () => {\n    return this.keyActive;\n  };\n\n  /**\n   * Allows toggling the session key on and off. When the session key is off,\n   * the fallback signer will be used instead.\n   *\n   * @param active whether or not to use the session key\n   * @returns\n   */\n  setKeyActive = (active: boolean) => {\n    return (this.keyActive = active);\n  };\n\n  /**\n   * Generates a new private key and stores it in the storage.\n   *\n   * @returns The public address of the new key.\n   */\n  generateNewKey = () => {\n    const storage =\n      this.storageType === \"session-storage\" ? sessionStorage : localStorage;\n\n    const newKey = generatePrivateKey();\n    storage.setItem(this.storageKey, newKey);\n    this.inner = LocalAccountSigner.privateKeyToAccountSigner(newKey);\n    this.keyActive = true;\n\n    return this.inner.inner.address;\n  };\n}\n"]}