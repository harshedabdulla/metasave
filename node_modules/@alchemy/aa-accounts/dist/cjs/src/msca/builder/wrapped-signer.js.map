{"version":3,"file":"wrapped-signer.js","sourceRoot":"","sources":["../../../../../src/msca/builder/wrapped-signer.ts"],"names":[],"mappings":";;;AACA,+BAMc;AACd,gEAG0C;AAGnC,MAAM,wBAAwB,GAAkB,CAAC,IAAI,EAAE,EAAE;IAC9D,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;IAE9B,IAAI,CAAC,KAAK,EAAE,CAAC;QACX,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;IACnE,CAAC;IAED,MAAM,kBAAkB,GAAG,KAAK,EAAE,GAAS,EAA0B,EAAE;QAErE,MAAM,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,AAAD,EAAG,IAAI,CAAC,GACtC,MAAM,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC;YAClC,GAAG,EAAE,+BAAmB;YACxB,OAAO,EAAE,4BAAgB,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC;YACnE,YAAY,EAAE,cAAc;YAC5B,OAAO,EAAE,MAAM,IAAI,CAAC,UAAU,EAAE;SACjC,CAAC,CAAC;QAEL,OAAO,KAAK,CAAC,aAAa,CAAC;YACzB,MAAM,EAAE;gBACN,OAAO,EAAE,MAAM,CAAC,OAAO,CAAC;gBACxB,IAAI;gBACJ,IAAI;gBACJ,iBAAiB,EAAE,MAAM,IAAI,CAAC,UAAU,EAAE;gBAC1C,OAAO;aACR;YACD,KAAK,EAAE;gBACL,4BAA4B,EAAE,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;aACnE;YACD,OAAO,EAAE;gBACP,OAAO,EAAE,GAAG;aACb;YACD,WAAW,EAAE,8BAA8B;SAC5C,CAAC,CAAC;IACL,CAAC,CAAC;IAEF,OAAO;QACL,iBAAiB;YACf,OAAO,sIAAsI,CAAC;QAChJ,CAAC;QAED,qBAAqB,CAAC,MAAqB;YACzC,OAAO,KAAK,CAAC,WAAW,CAAC,IAAA,iBAAU,EAAC,MAAM,CAAC,CAAC,CAAC;QAC/C,CAAC;QAED,WAAW,CAAC,GAAwB;YAClC,OAAO,kBAAkB,CACvB,IAAA,kBAAW,EACT,OAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,IAAA,cAAO,EAAC,GAAG,CAAC;gBACtC,CAAC,CAAC,GAAG;gBACL,CAAC,CAAC;oBACE,GAAG,EAAE,GAAG;iBACT,CACN,CACF,CAAC;QACJ,CAAC;QAED,aAAa,CAAC,MAA2B;YACvC,OAAO,kBAAkB,CAAC,IAAA,oBAAa,EAAC,MAAM,CAAC,CAAC,CAAC;QACnD,CAAC;KACF,CAAC;AACJ,CAAC,CAAC;AA5DW,QAAA,wBAAwB,4BA4DnC","sourcesContent":["import type { SignTypedDataParams } from \"@alchemy/aa-core\";\nimport {\n  hashMessage,\n  hashTypedData,\n  hexToBytes,\n  isBytes,\n  type Hash,\n} from \"viem\";\nimport {\n  MultiOwnerPlugin,\n  MultiOwnerPluginAbi,\n} from \"../plugins/multi-owner/plugin.js\";\nimport type { SignerMethods } from \"./types\";\n\nexport const WrapWith712SignerMethods: SignerMethods = (acct) => {\n  const owner = acct.getOwner();\n\n  if (!owner) {\n    throw new Error(\"owner is required for use with signer methods\");\n  }\n\n  const signWith712Wrapper = async (msg: Hash): Promise<`0x${string}`> => {\n    // TODO: right now this is hard coded to one Plugin address, but we should make this configurable somehow\n    const [, name, version, chainId, , salt] =\n      await acct.rpcProvider.readContract({\n        abi: MultiOwnerPluginAbi,\n        address: MultiOwnerPlugin.meta.addresses[acct.rpcProvider.chain.id],\n        functionName: \"eip712Domain\",\n        account: await acct.getAddress(),\n      });\n\n    return owner.signTypedData({\n      domain: {\n        chainId: Number(chainId),\n        name,\n        salt,\n        verifyingContract: await acct.getAddress(),\n        version,\n      },\n      types: {\n        AlchemyModularAccountMessage: [{ name: \"message\", type: \"bytes\" }],\n      },\n      message: {\n        message: msg,\n      },\n      primaryType: \"AlchemyModularAccountMessage\",\n    });\n  };\n\n  return {\n    getDummySignature(): `0x${string}` {\n      return \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n    },\n\n    signUserOperationHash(uoHash: `0x${string}`): Promise<`0x${string}`> {\n      return owner.signMessage(hexToBytes(uoHash));\n    },\n\n    signMessage(msg: string | Uint8Array): Promise<`0x${string}`> {\n      return signWith712Wrapper(\n        hashMessage(\n          typeof msg === \"string\" && !isBytes(msg)\n            ? msg\n            : {\n                raw: msg,\n              }\n        )\n      );\n    },\n\n    signTypedData(params: SignTypedDataParams): Promise<`0x${string}`> {\n      return signWith712Wrapper(hashTypedData(params));\n    },\n  };\n};\n"]}