import{poseidon as t,sha256 as e,Hex as r,base58FromBytes as n,base58ToBytes as i}from"@iden3/js-crypto";const s=Object.freeze({ERRORS:{DATA_OVERFLOW:new Error("data does not fits SNARK size"),INCORRECT_ID_POSITION:new Error("incorrect ID position"),NO_ID:new Error("ID is not set"),INVALID_SUBJECT_POSITION:new Error("invalid subject position"),INCORRECT_MERKLIZED_POSITION:new Error("incorrect Merklize position"),NO_MERKLIZED_ROOT:new Error("Merklized root is not set"),NETWORK_NOT_SUPPORTED_FOR_DID:new Error("network in not supported for did"),UNSUPPORTED_BLOCKCHAIN_FOR_DID:new Error("not supported blockchain for did"),UNSUPPORTED_DID_METHOD:new Error("not supported DID method"),UNKNOWN_DID_METHOD:new Error("unknown DID method"),INCORRECT_DID:new Error("incorrect DID"),UNSUPPORTED_ID:new Error("unsupported Id")},SCHEMA:{HASH_LENGTH:16},ETH_ADDRESS_LENGTH:20,BYTES_LENGTH:32,ELEM_BYTES_LENGTH:4,NONCE_BYTES_LENGTH:8,Q:BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617"),ID:{TYPE_DEFAULT:Uint8Array.from([0,0]),TYPE_READONLY:Uint8Array.from([0,1]),ID_LENGTH:31},DID:{DID_SCHEMA:"did"},GENESIS_LENGTH:27}),o={Ethereum:"eth",Polygon:"polygon",ZkEVM:"zkevm",Unknown:"unknown",NoChain:"",ReadOnly:"readonly"},a={Main:"main",Mumbai:"mumbai",Goerli:"goerli",Sepolia:"sepolia",Test:"test",Unknown:"unknown",NoNetwork:""},h={Iden3:"iden3",PolygonId:"polygonid",Other:""},u={[`${o.Ethereum}:${a.Main}`]:1,[`${o.Ethereum}:${a.Goerli}`]:5,[`${o.Ethereum}:${a.Sepolia}`]:11155111,[`${o.Polygon}:${a.Main}`]:137,[`${o.Polygon}:${a.Mumbai}`]:80001,[`${o.ZkEVM}:${a.Main}`]:1101,[`${o.ZkEVM}:${a.Test}`]:1442},l={[h.Iden3]:1,[h.PolygonId]:2,[h.Other]:255},c={[h.Iden3]:{[`${o.ReadOnly}:${a.NoNetwork}`]:0,[`${o.Polygon}:${a.Main}`]:17,[`${o.Polygon}:${a.Mumbai}`]:18,[`${o.Ethereum}:${a.Main}`]:33,[`${o.Ethereum}:${a.Goerli}`]:34,[`${o.Ethereum}:${a.Sepolia}`]:35,[`${o.ZkEVM}:${a.Main}`]:49,[`${o.ZkEVM}:${a.Test}`]:50},[h.PolygonId]:{[`${o.ReadOnly}:${a.NoNetwork}`]:0,[`${o.Polygon}:${a.Main}`]:17,[`${o.Polygon}:${a.Mumbai}`]:18,[`${o.Ethereum}:${a.Main}`]:33,[`${o.Ethereum}:${a.Goerli}`]:34,[`${o.Ethereum}:${a.Sepolia}`]:35,[`${o.ZkEVM}:${a.Main}`]:49,[`${o.ZkEVM}:${a.Test}`]:50},[h.Other]:{[`${o.Unknown}:${a.Unknown}`]:255}},d=new TextEncoder;function I(t){const e=BigInt(256);let r=BigInt(0),n=BigInt(1);return t.forEach((t=>{r+=n*BigInt(t),n*=e})),r}function E(t){return I(t.reverse())}function g(t,e=31){const r=BigInt(256),n=new Uint8Array(e);let i=0;for(;t>BigInt(0);)n[i]=Number(t%r),t/=r,i+=1;return n}function f(t,e=31){return g(t,e).reverse()}function w(t){const e=new ArrayBuffer(4);return new DataView(e).setUint32(0,t,!0),new Uint8Array(e)}function y(t){const e=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);return new DataView(e).getUint32(0,!0)}function m(t){const e=new ArrayBuffer(8);return new DataView(e).setBigUint64(0,t,!0),new Uint8Array(e)}function _(t){const e=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);return new DataView(e).getBigUint64(0,!0)}function S(t){return Math.floor(t.getTime()/1e3)}function b(t){return new Date(1e3*t)}function x(t){return t<s.Q}function N(t){return t.every((t=>x(t)))}function p(e,r,n){return t.hash([e,r,n])}class D{static isNotValidIDChar(t){return D.isNotAlpha(t)&&D.isNotDigit(t)&&"."!==t&&"-"!==t}static isNotValidParamChar(t){return D.isNotAlpha(t)&&D.isNotDigit(t)&&"."!==t&&"-"!==t&&"_"!==t&&":"!==t}static isNotValidQueryOrFragmentChar(t){return D.isNotValidPathChar(t)&&"/"!==t&&"?"!==t}static isNotValidPathChar(t){return D.isNotUnreservedOrSubdelim(t)&&":"!==t&&"@"!==t}static isNotUnreservedOrSubdelim(t){switch(t){case"-":case".":case"_":case"~":case"!":case"$":case"&":case"'":case"(":case")":case"*":case"+":case",":case";":case"=":return!1;default:return!(!D.isNotAlpha(t)||!D.isNotDigit(t))}}static isNotHexDigit(t){return D.isNotDigit(t)&&(t<"A"||t>"F")&&(t<"a"||t>"f")}static isNotDigit(t){return t<"0"||t>"9"}static isNotAlpha(t){return D.isNotSmallLetter(t)&&D.isNotBigLetter(t)}static isNotBigLetter(t){return t<"A"||t>"Z"}static isNotSmallLetter(t){return t<"a"||t>"z"}}const O=t=>Uint8Array.from([...new Uint8Array(7),...t]);class T{static intToBytes(t){return T.intToNBytes(t,s.BYTES_LENGTH)}static intToNBytes(t,e){return Uint8Array.from(g(t,e))}static checkChecksum(t){const{typ:e,genesis:r,checksum:n}=T.decomposeBytes(t);if(!n.length||JSON.stringify(Uint8Array.from([0,0]))===JSON.stringify(n))return!1;const i=T.calculateChecksum(e,r);return JSON.stringify(i)===JSON.stringify(n)}static decomposeBytes(t){const e=t.length-2;return{typ:t.slice(0,2),genesis:t.slice(2,e),checksum:t.slice(-2)}}static calculateChecksum(t,e){const r=[...t,...e].reduce(((t,e)=>t+e),0),n=[r>>8,255&r];return Uint8Array.from(n.reverse())}static hashBytes(t){const r=e(d.encode(t));return new Uint8Array(r)}static hexToBytes(t){return r.decodeString(t)}static bytesToHex(t){const e=[];for(let r=0;r<t.length;r++){const n=t[r]<0?t[r]+256:t[r];e.push((n>>>4).toString(16)),e.push((15&n).toString(16))}return e.join("")}static bytesToInt(t){return I(t)}}class R{constructor(t){if(this._bytes=new Uint8Array(s.BYTES_LENGTH),t&&(this._bytes=t),this._bytes.length!==s.BYTES_LENGTH)throw new Error("Invalid bytes length")}get bytes(){return this._bytes}set bytes(t){this._bytes=t}toBigInt(){return T.bytesToInt(this._bytes)}setBigInt(t){if(!x(t))throw s.ERRORS.DATA_OVERFLOW;return this._bytes=T.intToBytes(t),this}slotFromHex(t){const e=r.decodeString(t);if(e.length!==s.BYTES_LENGTH)throw new Error("Invalid bytes length");return this._bytes.set(e,0),this}hex(){return r.encodeString(this._bytes)}static elemBytesToInts(t){const e=[];for(let r=0;r<t.length;r++){const n=t[r];e.push(n.toBigInt())}return e}static fromInt(t){if(!x(t))throw s.ERRORS.DATA_OVERFLOW;const e=T.intToBytes(t);return new R(e)}}class B{constructor(t){if(this._bytes=new Uint8Array(s.SCHEMA.HASH_LENGTH),t&&(this._bytes=t),this.bytes.length!==s.SCHEMA.HASH_LENGTH)throw new Error(`Schema hash must be ${s.SCHEMA.HASH_LENGTH} bytes long`)}get bytes(){return this._bytes}marshalTextBytes(){return r.encode(this.bytes)}marshalText(){return r.encodeString(this.bytes)}static newSchemaHashFromHex(t){const e=r.decodeString(t);if(e.length!==s.SCHEMA.HASH_LENGTH)throw new Error(`invalid schema hash length: ${e.length}`);return new B(e)}static newSchemaHashFromInt(t){const e=T.intToNBytes(t,s.SCHEMA.HASH_LENGTH),r=s.SCHEMA.HASH_LENGTH-e.length;return new B(T.intToBytes(t).slice(r,s.SCHEMA.HASH_LENGTH))}bigInt(){return T.bytesToInt(this.bytes)}}B.authSchemaHash=new B(Uint8Array.from([204,163,55,26,108,177,183,21,0,68,7,227,37,189,153,60]));class k{constructor(t,e){this._checksum=T.calculateChecksum(t,e),this._bytes=Uint8Array.from([...t,...e,...this._checksum])}static getFromBytes(t){const{typ:e,genesis:r}=T.decomposeBytes(t);return new k(e,r)}checksum(){return this._checksum}string(){return n(this._bytes)}get bytes(){return this._bytes}set bytes(t){this._bytes=t}type(){return this._bytes.slice(0,2)}bigInt(){return I(this._bytes)}equal(t){return JSON.stringify(this._bytes)===JSON.stringify(t.bytes)}marshal(){return(new TextEncoder).encode(this.string())}static unMarshal(t){return k.fromString((new TextDecoder).decode(t))}static fromBytes(t){const e=t??Uint8Array.from([]);if(e.length!==s.ID.ID_LENGTH)throw new Error("fromBytes error: byte array incorrect length");if(e.every((t=>0===t)))throw new Error("fromBytes error: byte array empty");const r=k.getFromBytes(e);if(!T.checkChecksum(e))throw new Error("fromBytes error: checksum error");return r}static fromString(t){const e=i(t);return k.fromBytes(e)}static fromBigInt(t){const e=T.intToNBytes(t,s.ID.ID_LENGTH);return k.fromBytes(e)}static profileId(e,r){const n=t.hash([e.bigInt(),r]),{typ:i}=T.decomposeBytes(e.bytes),s=T.intToNBytes(n,27);return new k(i,s)}static idGenesisFromIdenState(t,e){const r=R.fromInt(e),n=r.bytes.slice(r.bytes.length-27);return new k(t,n)}static ethAddressFromId(t){if(!t.bytes.slice(2,9).every((t=>0===t)))throw new Error("can't get Ethereum address: high bytes of genesis are not zero");return t.bytes.slice(9).slice(0,s.ETH_ADDRESS_LENGTH)}}var H,$,A,V,U,M;!function(t){t.IndexA="IndexA",t.IndexB="IndexB",t.ValueA="ValueA",t.ValueB="ValueB"}(H||(H={}));class L extends Error{constructor(t){super(`Slot ${t} not in field (too large)`),Object.setPrototypeOf(this,L.prototype)}}!function(t){t[t.Self=0]="Self",t[t.Invalid=1]="Invalid",t[t.OtherIdenIndex=2]="OtherIdenIndex",t[t.OtherIdenValue=3]="OtherIdenValue"}($||($={})),function(t){t[t.None=0]="None",t[t.Index=1]="Index",t[t.Value=2]="Value"}(A||(A={})),function(t){t[t.None=0]="None",t[t.Index=32]="Index",t[t.Value=64]="Value",t[t.Invalid=128]="Invalid"}(V||(V={})),function(t){t[t.None=0]="None",t[t.Index=1]="Index",t[t.Value=2]="Value"}(U||(U={})),function(t){t[t.ByteIdx=16]="ByteIdx",t[t.ExpirationBitIdx=3]="ExpirationBitIdx",t[t.UpdatableBitIdx=4]="UpdatableBitIdx"}(M||(M={}));class v{constructor(){this._index=[],this._value=[];for(let t=0;t<s.ELEM_BYTES_LENGTH;t++)this._index[t]=new R,this._value[t]=new R}static newClaim(t,...e){const r=new v;r.setSchemaHash(t);for(let t=0;t<e.length;t++){(0,e[t])(r)}return r}getSchemaHash(){return new B(this._index[0].bytes.slice(0,s.SCHEMA.HASH_LENGTH))}get value(){return this._value}set value(t){this._value=t}get index(){return this._index}set index(t){this._index=t}setSchemaHash(t){this._index[0]=new R(Uint8Array.from([...t.bytes,...new Array(s.SCHEMA.HASH_LENGTH).fill(0)]))}setSubject(t){this._index[0].bytes[M.ByteIdx]&=248,this._index[0].bytes[M.ByteIdx]|=t}getSubject(){let t=this._index[0].bytes[M.ByteIdx];return t&=7,t}setFlagExpiration(t){t?this._index[0].bytes[M.ByteIdx]|=1<<M.ExpirationBitIdx:this._index[0].bytes[M.ByteIdx]&=~(1<<M.ExpirationBitIdx)}getFlagExpiration(){const t=1<<M.ExpirationBitIdx;return(this._index[0].bytes[M.ByteIdx]&t)>0}getIdPosition(){switch(this.getSubject()){case $.Self:return A.None;case $.OtherIdenIndex:return A.Index;case $.OtherIdenValue:return A.Value;default:throw s.ERRORS.INVALID_SUBJECT_POSITION}}setValueDataInts(t,e){this._value[2]=this.setSlotInt(t,H.ValueA),this._value[3]=this.setSlotInt(e,H.ValueB)}setValueDataBytes(t,e){this._value[2]=this.setSlotBytes(t,H.ValueA),this._value[3]=this.setSlotBytes(e,H.ValueB)}setValueData(t,e){if(!N([t.toBigInt(),e.toBigInt()]))throw s.ERRORS.DATA_OVERFLOW;this._value[2]=t,this._value[3]=e}setIndexDataInts(t,e){this._index[2]=this.setSlotInt(t,H.IndexA),this._index[3]=this.setSlotInt(e,H.IndexB)}setIndexDataBytes(t,e){this._index[2]=this.setSlotBytes(t,H.IndexA),this._index[3]=this.setSlotBytes(e,H.IndexB)}setSlotBytes(t,e){const r=new R(t);if(!x(r.toBigInt()))throw new L(e);return r}setFlagMerklized(t){let e;switch(t){case U.Index:e=V.Index;break;case U.Value:e=V.Value;break;default:e=V.None}this.index[0].bytes[M.ByteIdx]&=31,this.index[0].bytes[M.ByteIdx]|=e}getMerklized(){let t=this.index[0].bytes[M.ByteIdx];return t&=224,t}getMerklizedPosition(){switch(this.getMerklized()){case V.None:return U.None;case V.Index:return U.Index;case V.Value:return U.Value;default:throw s.ERRORS.INCORRECT_MERKLIZED_POSITION}}setSlotInt(t,e){if(t||(t=BigInt(0)),!x(t))throw new L(e);return(new R).setBigInt(t)}setIndexData(t,e){if(!N([t.toBigInt(),e.toBigInt()]))throw s.ERRORS.DATA_OVERFLOW;this._index[2]=t,this._index[3]=e}resetExpirationDate(){this.setFlagExpiration(!1);const t=Array.from({length:s.NONCE_BYTES_LENGTH},(()=>0)),e=Array.from(this._value[0].bytes);e.splice(s.NONCE_BYTES_LENGTH,s.NONCE_BYTES_LENGTH,...t),this._value[0]=new R(Uint8Array.from(e))}getExpirationDate(){if(this.getFlagExpiration()){const t=_(this._value[0].bytes.slice(8,16));return b(Number(t))}return null}setExpirationDate(t){this.setFlagExpiration(!0);const e=m(BigInt(S(t))),r=Array.from(this._value[0].bytes);r.splice(s.NONCE_BYTES_LENGTH,s.NONCE_BYTES_LENGTH,...e),this._value[0]=new R(Uint8Array.from(r))}getRevocationNonce(){return _(this._value[0].bytes.slice(0,8))}setRevocationNonce(t){const e=m(t);if(e.length>s.NONCE_BYTES_LENGTH)throw new Error("Nonce length is not valid");const r=Array.from(this._value[0].bytes);r.splice(0,s.NONCE_BYTES_LENGTH,...e),this._value[0]=new R(Uint8Array.from(r))}getValueId(){return k.fromBytes(this._value[1].bytes.slice(0,-1))}setValueId(t){this.resetIndexId(),this.setSubject($.OtherIdenValue);const e=Array.from(this._index[1].bytes);e.splice(0,t.bytes.length,...t.bytes),this._value[1]=new R(Uint8Array.from(e))}resetIndexId(){this._index[1]=new R(new Uint8Array(s.BYTES_LENGTH).fill(0))}resetValueId(){this._value[1]=new R(new Uint8Array(s.BYTES_LENGTH).fill(0))}getIndexId(){return k.fromBytes(this._index[1].bytes.slice(0,-1))}setIndexId(t){this.resetValueId(),this.setSubject($.OtherIdenIndex);const e=Array.from(this._index[1].bytes);e.splice(0,t.bytes.length,...t.bytes),this._index[1]=new R(Uint8Array.from(e))}setVersion(t){const e=w(t);this._index[0].bytes[20]=e[0],this._index[0].bytes[21]=e[1],this._index[0].bytes[22]=e[2],this._index[0].bytes[23]=e[3]}getVersion(){return y(this._index[0].bytes.slice(20,24))}setFlagUpdatable(t){t?this._index[0].bytes[M.ByteIdx]|=1<<M.UpdatableBitIdx:this._index[0].bytes[M.ByteIdx]&=~(1<<M.UpdatableBitIdx)}hIndex(){return t.hash(R.elemBytesToInts(this._index))}getFlagUpdatable(){const t=1<<M.UpdatableBitIdx;return(this._index[0].bytes[M.ByteIdx]&t)>0}hValue(){return t.hash(R.elemBytesToInts(this._value))}hiHv(){return{hi:this.hIndex(),hv:this.hValue()}}setIndexMerklizedRoot(t){this.resetValueMerklizedRoot(),this.setFlagMerklized(U.Index),this.index[2]=this.setSlotInt(t,H.IndexA)}resetIndexMerklizedRoot(){this._index[2]=new R(new Uint8Array(s.BYTES_LENGTH).fill(0))}setValueMerklizedRoot(t){this.resetIndexMerklizedRoot(),this.setFlagMerklized(U.Value),this.value[2]=this.setSlotInt(t,H.ValueA)}resetValueMerklizedRoot(){this._value[2]=new R(new Uint8Array(s.BYTES_LENGTH).fill(0))}getMerklizedRoot(){switch(this.getMerklized()){case V.Index:return this.index[2].toBigInt();case V.Value:return this.value[2].toBigInt();default:throw s.ERRORS.NO_MERKLIZED_ROOT}}resetId(){this.resetIndexId(),this.resetValueId(),this.setSubject($.Self)}getId(){switch(this.getSubject()){case $.OtherIdenIndex:return this.getIndexId();case $.OtherIdenValue:return this.getValueId();default:throw s.ERRORS.NO_ID}}rawSlots(){return{index:this._index,value:this._value}}rawSlotsAsInts(){return[...R.elemBytesToInts(this._index),...R.elemBytesToInts(this._value)]}clone(){return JSON.parse(JSON.stringify(this))}marshalJson(){return this.rawSlotsAsInts().map((t=>t.toString()))}unMarshalJson(t){const e=JSON.parse(t).map((t=>BigInt(t)));if(e.length!==this._index.length+this._value.length)throw new Error("invalid number of claim's slots");this._index=[],this._value=[];for(let t=0,r=s.ELEM_BYTES_LENGTH;t<e.length/2;t++,r++)this._index[t]=new R,this._index[t].setBigInt(e[t]),this._value[t]=new R,this._value[t].setBigInt(e[r]);return this}marshalBinary(){const t=t=>t.reduce(((t,e)=>[...t,...e.bytes]),[]);return Uint8Array.from(t(this._index).concat(t(this._value)))}hex(){const t=this.marshalBinary();return r.encodeString(t)}fromHex(t){const e=r.decodeString(t);return this.unMarshalBinary(e),this}unMarshalBinary(t){const e=2*s.ELEM_BYTES_LENGTH*s.BYTES_LENGTH;if(t.length!==e)throw new Error("unexpected length of input data");this._index=[],this._value=[];for(let e=0,r=s.ELEM_BYTES_LENGTH;e<s.ELEM_BYTES_LENGTH;e++,r++)this._index[e]=new R(t.slice(e*s.BYTES_LENGTH,(e+1)*s.BYTES_LENGTH)),this._value[e]=new R(t.slice(r*s.BYTES_LENGTH,(r+1)*s.BYTES_LENGTH))}}class C{static withFlagUpdatable(t){return e=>e.setFlagUpdatable(t)}static withVersion(t){return e=>e.setVersion(t)}static withIndexId(t){return e=>e.setIndexId(t)}static withValueId(t){return e=>e.setValueId(t)}static withFlagMerklized(t){return e=>e.setFlagMerklized(t)}static withId(t,e){return r=>{switch(e){case A.Index:r.setIndexId(t);break;case A.Value:r.setValueId(t);break;default:throw s.ERRORS.INCORRECT_ID_POSITION}}}static withRevocationNonce(t){return e=>e.setRevocationNonce(t)}static withExpirationDate(t){return e=>e.setExpirationDate(t)}static withIndexData(t,e){return r=>r.setIndexData(t,e)}static withIndexDataBytes(t,e){return r=>r.setIndexDataBytes(t,e)}static withIndexDataInts(t,e){return r=>r.setIndexDataInts(t,e)}static withValueData(t,e){return r=>r.setValueData(t,e)}static withValueDataBytes(t,e){return r=>r.setValueDataBytes(t,e)}static withValueDataInts(t,e){return r=>r.setValueDataInts(t,e)}static withIndexMerklizedRoot(t){return e=>{e.setFlagMerklized(U.Index),e.index[2]=e.setSlotInt(t,H.IndexA)}}static withValueMerklizedRoot(t){return e=>{e.setFlagMerklized(U.Value),e.value[2]=e.setSlotInt(t,H.ValueA)}}static withMerklizedRoot(t,e){return r=>{switch(e){case U.Index:r.setFlagMerklized(U.Index),r.index[2]=r.setSlotInt(t,H.IndexA);break;case U.Value:r.setFlagMerklized(U.Value),r.value[2]=r.setSlotInt(t,H.ValueA);break;default:throw s.ERRORS.INCORRECT_MERKLIZED_POSITION}}}}class F{constructor(t,e){this.blockchain=t,this.networkId=e}toString(){return`${this.blockchain}:${this.networkId}`}static fromString(t){const[e,r]=t.split(":");return new F(e.replace("_",""),r.replace("_",""))}}function P(t,e,r){const n=l[t];if(!n)throw s.ERRORS.UNSUPPORTED_DID_METHOD;const i=c[t];if(!i)throw s.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID;const o=i[new F(e,r).toString()];if("number"!=typeof o)throw new Error(`blockchain ${e.toString()??"-"} and network ${r.toString()??"-"} is not defined in core lib`);return Uint8Array.from([n,o])}function G(t,e){const r=c[t];if(!r)throw s.ERRORS.UNSUPPORTED_DID_METHOD;for(const[t,n]of Object.entries(r))if(n===e)return F.fromString(t).networkId;throw s.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID}function z(t,e){const r=c[t];if(!r)throw new Error(`${s.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID}: did method ${t} is not defined in core lib`);for(const[t,n]of Object.entries(r))if(n===e)return F.fromString(t).blockchain;throw s.ERRORS.UNSUPPORTED_BLOCKCHAIN_FOR_DID}function Y(t){for(const[e,r]of Object.entries(l))if(r===t)return e;throw s.ERRORS.UNSUPPORTED_DID_METHOD}class j{constructor(t,e){this.name=t,this.value=e}toString(){return this.name?this.value?`${this.name}=${this.value}`:this.name:""}}const K=Object.freeze({method:"",id:"",idStrings:[],params:[],path:"",pathSegments:[],query:"",fragment:""});class J{constructor(t){this.input=t,this.currentIndex=0,this.out={...K}}checkLength(){if(this.input.length<7)throw new Error("input length is less than 7");return this.parseScheme.bind(this)}parseScheme(){if("did:"!==this.input.slice(0,4))throw new Error("input does not begin with 'did:' prefix");return this.currentIndex=3,this.parseMethod.bind(this)}parseMethod(){const t=this.input,e=t.length;let r=this.currentIndex+1;const n=r;for(;;){if(r===e)throw new Error("input does not have a second `:` marking end of method name");const i=t[r];if(":"===i){if(r===n)throw new Error(`method is empty, ${r}`);break}if(D.isNotDigit(i)&&D.isNotSmallLetter(i))throw new Error(`"character is not a-z OR 0-9, ${r}`);r+=1}return this.currentIndex=r,this.out.method=t.slice(n,r),this.parseId.bind(this)}parseId(){const t=this.input,e=t.length;let r=this.currentIndex+1;const n=r;let i=null;for(;;){if(r===e){i=null;break}const n=t[r];if(":"===n){i=this.parseId;break}if(";"===n){i=this.parseParamName;break}if("/"===n){i=this.parsePath;break}if("?"===n){i=this.parseQuery;break}if("#"===n){i=this.parseFragment;break}if(D.isNotValidIDChar(n))throw new Error(`byte is not ALPHA OR DIGIT OR '.' OR '-', ${r}`);r+=1}if(r===n)throw new Error(`idstring must be atleast one char long, ${r}`);return this.currentIndex=r,this.out.idStrings=[...this.out.idStrings,t.slice(n,r)],i?i.bind(this):null}parseParamName(){const t=this.input,e=this.currentIndex+1,r=this.paramTransition(),n=this.currentIndex;if(n===e)throw new Error(`Param name must be at least one char long, ${n}`);return this.out.params=[...this.out.params,new j(t.slice(e,n),"")],r?r.bind(this):null}parseParamValue(){const t=this.input,e=this.currentIndex+1,r=this.paramTransition(),n=this.currentIndex;return this.out.params[this.out.params.length-1].value=t.slice(e,n),r?r.bind(this):null}paramTransition(){const t=this.input,e=t.length;let r,n,i,s=this.currentIndex+1;for(;;){if(s===e){n=null;break}const o=t[s];if(";"===o){n=this.parseParamName;break}if("="===o){n=this.parseParamValue;break}if("/"===o){n=this.parsePath;break}if("?"===o){n=this.parseQuery;break}if("#"==o){n=this.parseFragment;break}if("%"==o){if(s+2>=e||D.isNotHexDigit(t[s+1])||D.isNotHexDigit(t[s+2]))throw new Error(`% is not followed by 2 hex digits', ${s}`);i=!0,r=3}else i=!1,r=1;if(!i&&D.isNotValidParamChar(o))throw new Error(`character is not allowed in param - ${o}',  ${s}`);s+=r}return this.currentIndex=s,n?n.bind(this):null}parsePath(){const t=this.input,e=t.length;let r=this.currentIndex+1;const n=r;let i,s,o;for(;;){if(r===e){s=null;break}const n=t[r];if("/"===n){s=this.parsePath;break}if("?"===n){s=this.parseQuery;break}if("%"===n){if(r+2>=e||D.isNotHexDigit(t[r+1])||D.isNotHexDigit(t[r+2]))throw new Error(`% is not followed by 2 hex digits, ${r}`);o=!0,i=3}else o=!1,i=1;if(!o&&D.isNotValidPathChar(n))throw new Error(`character is not allowed in path, ${r}`);r+=i}if(r==n&&0===this.out.pathSegments.length)throw new Error(`first path segment must have atleast one character, ${r}`);return this.currentIndex=r,this.out.pathSegments=[...this.out.pathSegments,t.slice(n,r)],s?s.bind(this):null}parseQuery(){const t=this.input,e=t.length;let r=this.currentIndex+1;const n=r;let i,s,o=null;for(;r!==e;){const n=t[r];if("#"===n){o=this.parseFragment;break}if("%"===n){if(r+2>=e||D.isNotHexDigit(t[r+1])||D.isNotHexDigit(t[r+2]))throw new Error(`% is not followed by 2 hex digits, ${r}`);s=!0,i=3}else s=!1,i=1;if(!s&&D.isNotValidQueryOrFragmentChar(n))throw new Error(`character is not allowed in query - ${n}`);r+=i}return this.currentIndex=r,this.out.query=t.slice(n,r),o?o.bind(this):null}parseFragment(){const t=this.input,e=this.input.length;let r=this.currentIndex+1;const n=r;let i,s;for(;r!==e;){const n=t[r];if("%"===n){if(r+2>=e||D.isNotHexDigit(t[r+1])||D.isNotHexDigit(t[r+2]))throw new Error(`% is not followed by 2 hex digits, ${r}`);s=!0,i=3}else s=!1,i=1;if(!s&&D.isNotValidQueryOrFragmentChar(n))throw new Error(`character is not allowed in fragment - ${n}`);r+=i}return this.currentIndex=r,this.out.fragment=t.slice(n,r),null}}class W{constructor(t){this.method="",this.id="",this.idStrings=[],this.params=[],this.path="",this.pathSegments=[],this.query="",this.fragment="",t&&Object.assign(this,t)}isUrl(){return this.params.length>0||!!this.path||this.pathSegments.length>0||!!this.query||!!this.fragment}string(){const t=["did:"];if(!this.method)return"";if(t.push(`${this.method}:`),this.id)t.push(this.id);else{if(!this.idStrings.length)return"";t.push(this.idStrings.join(":"))}if(this.params.length)for(const e of this.params){const r=e.toString();if(!r)return"";t.push(`;${r}`)}return this.path?t.push(`/${this.path}`):this.pathSegments.length&&t.push(`/${this.pathSegments.join("/")}`),this.query&&t.push(`?${this.query}`),this.fragment&&t.push(`#${this.fragment}`),t.join("")}static parse(t){const e=new J(t);let r=e.checkLength();for(;r;)r=r();return e.out.id=e.out.idStrings.join(":"),e.out.path=e.out.pathSegments.join("/"),new W(e.out)}static decodePartsFromId(t){const e=Y(t.bytes[0]);return{method:e,blockchain:z(e,t.bytes[1]),networkId:G(e,t.bytes[1])}}static networkIdFromId(t){return W.throwIfDIDUnsupported(t).networkId}static methodFromId(t){return W.throwIfDIDUnsupported(t).method}static blockchainFromId(t){return W.throwIfDIDUnsupported(t).blockchain}static throwIfDIDUnsupported(t){const{method:e,blockchain:r,networkId:n}=W.decodePartsFromId(t);if(W.isUnsupported(e,r,n))throw new Error(`${s.ERRORS.UNKNOWN_DID_METHOD.message}: unsupported DID`);return{method:e,blockchain:r,networkId:n}}static newFromIdenState(t,e){const r=k.idGenesisFromIdenState(t,e);return W.parseFromId(r)}static new(t,e){return W.parseFromId(new k(t,e))}static parseFromId(t){if(!T.checkChecksum(t.bytes))throw new Error(`${s.ERRORS.UNSUPPORTED_ID.message}: invalid checksum`);const{method:e,blockchain:r,networkId:n}=W.throwIfDIDUnsupported(t),i=[s.DID.DID_SCHEMA,e.toString(),r.toString()];n&&i.push(n.toString()),i.push(t.string());const o=i.join(":");return W.parse(o)}static idFromDID(t){let e;try{e=W.getIdFromDID(t)}catch(e){if(e.message===s.ERRORS.UNKNOWN_DID_METHOD.message)return W.idFromUnsupportedDID(t);throw e}return e}static isUnsupported(t,e,r){return t==h.Other&&e==o.Unknown&&r==a.Unknown}static idFromUnsupportedDID(t){const r=e(d.encode(t.string())),n=new Uint8Array(27),i=r.slice(r.length-s.GENESIS_LENGTH);for(let t=0;t<n.length;t++)n[t]=i[t]??0;const u=new F(o.Unknown,a.Unknown),I=Uint8Array.from([l[h.Other],c[h.Other][u.toString()]]);return new k(I,n)}static getIdFromDID(t){const e=t.method;if(!l[e]||e===h.Other)throw s.ERRORS.UNKNOWN_DID_METHOD;if(t.idStrings.length>3||t.idStrings.length<2)throw new Error(`${s.ERRORS.INCORRECT_DID}: unexpected number of ID strings`);const r=k.fromString(t.idStrings[t.idStrings.length-1]);if(!T.checkChecksum(r.bytes))throw new Error(`${s.ERRORS.INCORRECT_DID}: incorrect ID checksum`);const{method:n,blockchain:i,networkId:o}=W.decodePartsFromId(r);if(n.toString()!==e.toString())throw new Error(`${s.ERRORS.INCORRECT_DID}: methods in Id and DID are different`);if(i.toString()!==t.idStrings[0])throw new Error(`${s.ERRORS.INCORRECT_DID}: blockchains in ID and DID are different`);if(t.idStrings.length>2&&o.toString()!=t.idStrings[1])throw new Error(`${s.ERRORS.INCORRECT_DID}: networkIDs in Id and DID are different`);return r}}const Z=t=>{o[t]=t},Q=t=>{a[t]=t},q=(t,e)=>{const r=l[h.Other];if(e>=r)throw new Error(`Can't register DID method byte: current '${e.toString(2)}', maximum byte allowed: '${(r-1).toString(2)}'`);if("number"!=typeof l[t]||l[t]!==e){if(Object.values(l).includes(e))throw new Error(`can't register method '${t}' because DID method byte '${e.toString(2)}' already registered for another method`);h[t]=t,l[t]=e}},X=(t,e,r)=>{const n=`${t}:${e}`;if("number"!=typeof u[n]||u[n]!==r){if(Object.values(u).includes(r))throw new Error(`can't register chainId ${r} for '${t}:${e}' because it's already registered for another chain id`);u[n]=r}},tt=(t,e)=>{e&&(t+=`:${e}`);const r=u[t];if(!r)throw new Error(`chainId not found for ${t}`);return r},et=t=>{const e=W.idFromDID(t),r=W.blockchainFromId(e),n=W.networkIdFromId(e),i=u[`${r}:${n}`];if("number"!=typeof i)throw new Error(`chainId not found for ${r}:${n}`);return i},rt=({method:t,methodByte:e,blockchain:r,network:n,chainId:i,networkFlag:s})=>{Z(r),Q(n),"number"==typeof e&&q(t,e),c[t]||(c[t]={}),"number"==typeof i&&X(r,n,i);const o=`${r}:${n}`,a=c[t][o];if("number"!=typeof a||a!==s){if(Object.values(c[t]).includes(s))throw new Error(`DID network flag ${s.toString(2)} is already registered for the another network id for '${t}' method`);c[t][o]=s}};export{o as Blockchain,T as BytesHelper,u as ChainIds,v as Claim,C as ClaimOptions,s as Constants,W as DID,F as DIDNetworkFlag,h as DidMethod,l as DidMethodByte,c as DidMethodNetwork,R as ElemBytes,L as ErrSlotOverflow,M as Flags,k as Id,A as IdPosition,V as MerklizedFlag,U as MerklizedRootPosition,a as NetworkId,j as Param,J as Parser,B as SchemaHash,H as SlotName,D as StringUtils,$ as SubjectFlag,P as buildDIDType,et as chainIDfromDID,N as checkBigIntArrayInField,x as checkBigIntInField,d as encoder,z as findBlockchainForDIDMethodByValue,Y as findDIDMethodByValue,G as findNetworkIDForDIDMethodByValue,E as fromBigEndian,I as fromLittleEndian,O as genesisFromEthAddress,tt as getChainId,b as getDateFromUnixTimestamp,y as getUint32,_ as getUint64,S as getUnixTimestamp,p as idenState,K as initDIDParams,w as putUint32,m as putUint64,Z as registerBlockchain,X as registerChainId,q as registerDidMethod,rt as registerDidMethodNetwork,Q as registerNetwork,f as toBigEndian,g as toLittleEndian};
//# sourceMappingURL=index.js.map
