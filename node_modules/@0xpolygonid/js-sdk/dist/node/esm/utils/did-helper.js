import { Hex } from '@iden3/js-crypto';
import { Id, buildDIDType, genesisFromEthAddress, DID } from '@iden3/js-iden3-core';
import { Hash } from '@iden3/js-merkletree';
/**
 * Checks if state is genesis state
 *
 * @param {string} did - did
 * @param {bigint|string} state  - hash on bigInt or hex string format
 * @returns boolean
 */
export function isGenesisState(did, state) {
    if (typeof state === 'string') {
        state = Hash.fromHex(state).bigInt();
    }
    const id = DID.idFromDID(did);
    const { method, blockchain, networkId } = DID.decodePartsFromId(id);
    const type = buildDIDType(method, blockchain, networkId);
    const idFromState = Id.idGenesisFromIdenState(type, state);
    return id.bigInt().toString() === idFromState.bigInt().toString();
}
export const buildVerifierId = (address, info) => {
    address = address.replace('0x', '');
    const ethAddrBytes = Hex.decodeString(address);
    const ethAddr = ethAddrBytes.slice(0, 20);
    const genesis = genesisFromEthAddress(ethAddr);
    const tp = buildDIDType(info.method, info.blockchain, info.networkId);
    return new Id(tp, genesis);
};
export const validateDIDDocumentAuth = async (did, resolverURL, state) => {
    const vm = await resolveDIDDocumentAuth(did, resolverURL, state);
    if (!vm) {
        throw new Error(`can't resolve DID document`);
    }
    // published or genesis
    if (!vm.published &&
        !isGenesisState(did, state.bigInt())) {
        throw new Error(`issuer state not published and not genesis`);
    }
};
export const resolveDIDDocumentAuth = async (did, resolveURL, state) => {
    let url = `${resolveURL}/${did.string().replace(/:/g, '%3A')}`;
    if (state) {
        url += `?state=${state.hex()}`;
    }
    const resp = await fetch(url);
    const didResolutionRes = (await resp.json());
    return didResolutionRes.didDocument?.verificationMethod?.find((i) => i.type === 'Iden3StateInfo2023');
};
